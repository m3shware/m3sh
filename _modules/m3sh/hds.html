

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>m3sh.hds &mdash; m3sh 1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
    <link rel="shortcut icon" href="../../_static/ghems_red.ico"/>
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=f2a433a1"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            m3sh
              <img src="../../_static/logo-small.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
   
              <p class="caption" role="heading"><span class="caption-text">Basic usage and examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../basics.html">Mesh basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../iterators.html">Neighborhood traversal</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Modules - API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../mesh.html">Halfedge data structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../helper.html">Auxiliary modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vis.html">Visualization</a></li>
</ul>

   <p class="caption">
     <span class="caption-text">Indices</span>
   </p>
   <ul>
        <li class="toctree-l1"><a href= "../../genindex.html">Index</a></li>
        <li class="toctree-l1"><a href= "../../py-modindex.html">Module index</a></li>
        <li class="toctree-l1"><a href= "https://github.com/m3shware/m3sh">Package source</a></li>
   </ul>
    

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">m3sh</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">m3sh.hds</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for m3sh.hds</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2024, m3shware</span>
<span class="c1">#</span>
<span class="c1"># Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="c1"># copy of this software and associated documentation files (the &quot;Software&quot;),</span>
<span class="c1"># to deal in the Software without restriction, including without limitation</span>
<span class="c1"># the rights to use, copy, modify, merge, publish, distribute, sublicense,</span>
<span class="c1"># and/or sell copies of the Software, and to permit persons to whom the</span>
<span class="c1"># Software is furnished to do so, subject to the following conditions:</span>
<span class="c1">#</span>
<span class="c1"># The above copyright notice and this permission notice shall be included in</span>
<span class="c1"># all copies or substantial portions of the Software.</span>
<span class="c1">#</span>
<span class="c1"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="c1"># IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="c1"># FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="c1"># AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="c1"># LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span>
<span class="c1"># FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS</span>
<span class="c1"># IN THE SOFTWARE.</span>

<span class="sd">&quot;&quot;&quot; Halfedge data structure.</span>

<span class="sd">An orientable 2-manifold mesh (with or without boundary) is described by</span>
<span class="sd">three containers:</span>

<span class="sd">    - a list of :class:`Vertex` objects,</span>
<span class="sd">    - a list of :class:`Face` objects,</span>
<span class="sd">    - and a dictionary of :class:`Halfedge` objects.</span>

<span class="sd">These containers and the relations between their items are managed by</span>
<span class="sd">the :class:`Mesh` class.</span>

<span class="sd">Note</span>
<span class="sd">----</span>
<span class="sd">To ease debugging, this module relies on assertions which can slow down</span>
<span class="sd">script execution. You can disable assertions by running in optimized mode</span>
<span class="sd">via the &quot;-O&quot; command line argument.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span>   <span class="c1">#use perf_counter instead</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span><span class="p">,</span> <span class="n">deepcopy</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">m3sh.obj</span> <span class="k">as</span> <span class="nn">obj</span>
<span class="kn">import</span> <span class="nn">m3sh.flags</span> <span class="k">as</span> <span class="nn">flags</span>


<div class="viewcode-block" id="Mesh">
<a class="viewcode-back" href="../../api/m3sh.hds.Mesh.html#m3sh.hds.Mesh">[docs]</a>
<span class="k">class</span> <span class="nc">Mesh</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Mesh kernel.</span>

<span class="sd">    The combinatorics of a mesh can be built by reading from a file or</span>
<span class="sd">    by converting a sequence of vertex coordinates and a sequence of face</span>
<span class="sd">    definitions to its halfedge representation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points : array_like, optional</span>
<span class="sd">        Vertex coordinates. Converted to an equivalent</span>
<span class="sd">        :obj:`~numpy.ndarray` object if necessary.</span>
<span class="sd">    faces : array_like, optional</span>
<span class="sd">        Face definitions, 0-based vertex indexing.</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        Name tag.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NonManifoldError</span>
<span class="sd">        When trying to initialize a mesh from non-manifold data.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    The `NumPy glossary &lt;https://numpy.org/doc/stable/glossary.html&gt;`_</span>
<span class="sd">    states the following about :term:`array_like` data representations:</span>

<span class="sd">        *Any scalar or sequence that can be interpreted as*</span>
<span class="sd">        :class:`numpy.ndarray`. *In addition to ndarrays and scalars</span>
<span class="sd">        this category includes lists (possibly nested and with different</span>
<span class="sd">        element types) and tuples. Any argument accepted by*</span>
<span class="sd">        :func:`numpy.array` *is array_like.*</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">faces</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Initialize from vertex and face lists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">CWHITERED</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\33</span><span class="s1">[41m&#39;</span>               <span class="c1"># white on red background</span>
        <span class="n">CEND</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\33</span><span class="s1">[0m&#39;</span>

        <span class="c1"># The points argument could also be an integer resulting in an</span>
        <span class="c1"># abstract connectivity-only halfedge mesh...</span>
        <span class="k">if</span> <span class="n">points</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">faces</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;face definitions require &#39;points&#39; argument != None&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span> <span class="o">=</span> <span class="p">[</span><span class="n">Vertex</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">))]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">CWHITERED</span><span class="si">}</span><span class="s2">array data buffer not owned by &quot;</span> <span class="o">+</span>
                      <span class="sa">f</span><span class="s2">&quot;&#39;points&#39; array</span><span class="si">{</span><span class="n">CEND</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Used to detect and handle non-manifold vertices during mesh</span>
        <span class="c1"># construction.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="p">}</span>

        <span class="c1"># User defined vertex, halfedge, and face data. Each container</span>
        <span class="c1"># holds tuples (name, attr, default) that describe the mesh</span>
        <span class="c1"># attribute name, the mesh item property name and the default</span>
        <span class="c1"># value when adding a new mesh item of the respective type.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vattr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hattr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fattr</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># A dictionary that maps pairs of vertices to halfedges. Useful</span>
        <span class="c1"># and efficient for checking if vertices are adjacent.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># Add all faces to the mesh. A vertex that does not get a valid</span>
        <span class="c1"># outgoing edge assigned during this process is disconnected from</span>
        <span class="c1"># all faces and not adjacent to any other vertex.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">faces</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">faces</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_face</span><span class="p">(</span><span class="n">face</span><span class="p">)</span>

            <span class="c1"># Typically one does not expect isolated vertices in a mesh </span>
            <span class="c1"># that does define faces (i.e., not a point cloud).</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">isolated</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">CWHITERED</span><span class="si">}</span><span class="s1">there are isolated vertices</span><span class="si">{</span><span class="n">CEND</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># Vertex neighborhood iterators will not work properly in the</span>
        <span class="c1"># presence of non-manifold vertices.</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">_manifold</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">NonManifoldError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;vertex #</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">_idx</span><span class="si">}</span><span class="s1"> is non-manifold&#39;</span><span class="p">)</span>

        <span class="c1"># The corresponding property setter will strip any directory</span>
        <span class="c1"># prefix and type suffix from the name.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="c1"># def __repr__(self):</span>
    <span class="c1">#     return (f&#39;Mesh({repr(self._points)}, \n&#39; +</span>
    <span class="c1">#             f&#39;{[[int(v) for v in f] for f in self]})&#39;)</span>

    <span class="c1"># def __str__(self):</span>
    <span class="c1">#     return (str(self._points)</span>
    <span class="c1">#             + &#39;\n[&#39; + &#39;\n &#39;.join([str(f) for f in self]) + &#39;]&#39;)</span>

<div class="viewcode-block" id="Mesh.__iter__">
<a class="viewcode-back" href="../../api/m3sh.hds.Mesh.__iter__.html#m3sh.hds.Mesh.__iter__">[docs]</a>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Face iterator.</span>

<span class="sd">        The returned iterator visits all faces of a mesh that are **not**</span>
<span class="sd">        marked as deleted in order of ascending face indices.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        Face</span>
<span class="sd">            Next face in insertion order traversal.</span>


<span class="sd">        The loop that visits all faces of a mesh that contribute to its</span>
<span class="sd">        combinatorics</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">           :linenos:</span>

<span class="sd">           for f in mesh:</span>
<span class="sd">               # do something with the face</span>
<span class="sd">               ...</span>

<span class="sd">        is equivalent to explicitly checking the :attr:`deleted` attribute</span>
<span class="sd">        of a face:</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">           :linenos:</span>

<span class="sd">           for f in mesh.faces:</span>
<span class="sd">               if not f.deleted:</span>
<span class="sd">                   # do something with the face</span>
<span class="sd">                   ...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">_deleted</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Shallow mesh copy.</span>

<span class="sd">        Duplicate the mesh combinatorics and vertex coordinates. Equivalent</span>
<span class="sd">        to :meth:`copy` method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Mesh</span>
<span class="sd">            Copy of the mesh.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Reserved for future use.</span>

<span class="sd">        Use :meth:`copy` to copy a halfedge mesh.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;use .copy() instead&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="Mesh.__getitem__">
<a class="viewcode-back" href="../../api/m3sh.hds.Mesh.__getitem__.html#m3sh.hds.Mesh.__getitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="c1"># Treat a mesh like a tuple consisting of a list of goemetric</span>
        <span class="c1"># vertices and face definitions.</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span>

        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;index must be 0 or 1, got </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Vertex coordinate array.</span>

<span class="sd">        Direct read and write access to vertex coordinates. Changing the</span>
<span class="sd">        size of the coordinate array is likely to break the halfedge data</span>
<span class="sd">        structure.</span>

<span class="sd">        :type: ~numpy.ndarray</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The vertex coordinate array contains coordinate entries of deleted</span>
<span class="sd">        vertices. Calling :meth:`clean` removes those entries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span>

    <span class="nd">@points</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Vertex list.</span>

<span class="sd">        Read access to the vertex list. This list should not be modified</span>
<span class="sd">        directly.</span>

<span class="sd">        :type: list[Vertex]</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The vertex list may contain deleted vertices. Call</span>
<span class="sd">        :meth:`~Mesh.clean` to remove deleted vertices from the vertex</span>
<span class="sd">        container.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">faces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Face list.</span>

<span class="sd">        Read access to the face list. This list should not be modified</span>
<span class="sd">        directly.</span>

<span class="sd">        :type: list[Face]</span>

<span class="sd">        This is **not** the list passed as argument `faces` during mesh</span>
<span class="sd">        construction but it can be generated easly with a list</span>
<span class="sd">        comprehension:</span>

<span class="sd">        &gt;&gt;&gt; faces = [[int(v) for v in f] for f in mesh]</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The face list may contain deleted faces. A call to</span>
<span class="sd">        :meth:`~Mesh.clean` will remove such entries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">halfedges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Halfedge dictionary.</span>

<span class="sd">        Dictionary that maps pairs of :class:`Vertex` objects to</span>
<span class="sd">        :class:`Halfedge` instances. Hence, to visit :class:`Halfedge`</span>
<span class="sd">        instances one can use</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            for h in mesh.halfedges.values():</span>
<span class="sd">                v = h.origin</span>
<span class="sd">                w = h.target</span>
<span class="sd">                ...</span>

<span class="sd">        to directly visit halfedges as :class:`Vertex` instance pairs use</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            for v, w in mesh.halfedges.keys():</span>
<span class="sd">                ...</span>

<span class="sd">        To check whether two vertices of a mesh are adjacent (connected</span>
<span class="sd">        by an edge) we can do one of the following. The resulting value</span>
<span class="sd">        depends on the chosen query method:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">           (v, w) in mesh.halfedges                 # True or False</span>
<span class="sd">           h = mesh.halfedges[v, w]                 # may raise KeyError</span>
<span class="sd">           h = mesh.halfedges.get((v, w))           # can result in h = None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Mesh size.</span>

<span class="sd">        Mesh size **not** accounting for deleted vertices and faces. The</span>
<span class="sd">        attribute value :math:`(v, e, f)` holds the number of vertices,</span>
<span class="sd">        the number of edges, and the number of faces.</span>

<span class="sd">        :type: (int, int, int)</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        In the presence of **deleted** items the value ``len(mesh.vertices)``</span>
<span class="sd">        (resp. ``len(mesh.faces)``) and the corresponding value of</span>
<span class="sd">        ``mesh.size`` are different.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_viter</span><span class="p">()),</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span>
                <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fiter</span><span class="p">()))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Name property.</span>

<span class="sd">        Name augmented with current time stamp.</span>

<span class="sd">        :type: str</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The returned string does not include a type suffix!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">date</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())[:</span><span class="mi">10</span><span class="p">]</span>
        <span class="n">time</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())[</span><span class="mi">11</span><span class="p">:</span><span class="mi">16</span><span class="p">]</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">date</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">time</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">value</span> <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">Path</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">stem</span>

<div class="viewcode-block" id="Mesh.from_grid">
<a class="viewcode-back" href="../../api/m3sh.hds.Mesh.from_grid.html#m3sh.hds.Mesh.from_grid">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_grid</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">triangulate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Alternative constructor.</span>

<span class="sd">        Construct mesh from grid data. By default a quadrilateral mesh with</span>
<span class="sd">        `mn` faces is generated from coordinate arrays of shape `(m, n)`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : ~numpy.ndarray, shape (m, n)</span>
<span class="sd">            Coordinate arrays.</span>
<span class="sd">        z : ~numpy.ndarray, shape (m, n), optional</span>
<span class="sd">            Coordinate array.</span>
<span class="sd">        triangulate : bool, optional</span>
<span class="sd">            Triangulate quadrilateral faces.</span>
<span class="sd">        name : str, optional</span>
<span class="sd">            Name tag.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Mesh</span>
<span class="sd">            Mesh instance.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Currently no `array_like` arguments are accepted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Raises an error if x has not the proper number of axis. Shapes</span>
        <span class="c1"># of y (and z if not None) have to match.</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="si">=}</span><span class="s2"> != (</span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="si">=}</span><span class="s2"> != (</span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="c1"># ravel() should not make copies and flatten in C-order, i.e.</span>
        <span class="c1"># rows are stored contiguously (stride n).</span>
        <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">z</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>

        <span class="c1"># Point cloud, faces are defined (and possibly triangulated) in the </span>
        <span class="c1"># nested for-loop.</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">triangulate</span><span class="p">:</span>
                    <span class="n">mesh</span><span class="o">.</span><span class="n">add_face</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">mesh</span><span class="o">.</span><span class="n">add_face</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span>      
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mesh</span><span class="o">.</span><span class="n">add_face</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> 
                                  <span class="n">n</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> 
                                  <span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> 
                                  <span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mesh</span></div>


<div class="viewcode-block" id="Mesh.read">
<a class="viewcode-back" href="../../api/m3sh.hds.Mesh.read.html#m3sh.hds.Mesh.read">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">merge</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Read mesh from file.</span>

<span class="sd">        Read mesh combinatorics (face definitions) and vertex coordinates</span>
<span class="sd">        from an OBJ file. Additional data is read on request.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            Name of an OBJ file.</span>
<span class="sd">        *args</span>
<span class="sd">            Variable number of arguments of type :class:`str`.</span>
<span class="sd">        quiet : bool, optional</span>
<span class="sd">            Suppress console output.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mesh : Mesh</span>
<span class="sd">            Mesh object.</span>
<span class="sd">        data : ndarray or tuple(ndarray, ...)</span>
<span class="sd">            Data blocks as requested via `args`. If a data block could</span>
<span class="sd">            not be read, a :obj:`None` value is returned.</span>


<span class="sd">        Vertex normals or texture coordinates stored in a file can be</span>
<span class="sd">        read via</span>

<span class="sd">        &gt;&gt;&gt; mesh, vecs, uvs = Mesh.read(filename, &#39;vn&#39;, &#39;vt&#39;)</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Additional return values (vertex normals, texture vertices, and</span>
<span class="sd">        custom data) are returned in the same order as they are presented</span>
<span class="sd">        in the argument list `args`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">CBOLD</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\33</span><span class="s1">[1m&#39;</span>                    <span class="c1"># bold text, white on black</span>
        <span class="n">CEND</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\33</span><span class="s1">[0m&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;reading </span><span class="si">{</span><span class="n">CBOLD</span><span class="si">}{</span><span class="n">Path</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="si">}{</span><span class="n">CEND</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; ...&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;v&#39;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;v&#39; cannot be used as argument&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;f&#39;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;f&#39; cannot be used as argument&quot;</span><span class="p">)</span>

        <span class="c1"># The *data expression will assign a list of all return values not</span>
        <span class="c1"># assigned to a name to data.</span>
        <span class="n">verts</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># Convert list of data blocks to a dictionary. Since insertion</span>
        <span class="c1"># order traversal is guaranteed, *data before conversion is equal</span>
        <span class="c1"># to *data.values() after conversion.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="n">arg</span><span class="p">:</span> <span class="n">block</span> <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">block</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">data</span><span class="p">)}</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; done (</span><span class="si">{</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> sec, </span><span class="si">{</span><span class="n">merge</span><span class="si">=}</span><span class="s1">)&#39;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t\u251c\u2500</span><span class="s2"> data block &#39;</span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2">&#39; &quot;</span> <span class="o">+</span>
                      <span class="sa">f</span><span class="s2">&quot;of size </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">arg</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t\u251c\u2500</span><span class="s1"> </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span><span class="si">}</span><span class="s1"> vertices&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t\u2514\u2500</span><span class="s1"> </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">faces</span><span class="p">)</span><span class="si">}</span><span class="s1"> faces&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">merge</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
            <span class="n">faces</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">faces</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;merged vertices of </span><span class="si">{</span><span class="n">CBOLD</span><span class="si">}{</span><span class="n">Path</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span> <span class="o">+</span>
                      <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">CEND</span><span class="si">}</span><span class="s1"> by distance (</span><span class="si">{</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> sec)&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;vn&#39;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="c1"># Check if each vertex is assigned the normal with identical</span>
            <span class="c1"># index value.</span>
            <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">faces</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">vn</span> <span class="ow">in</span> <span class="n">face</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">vn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">vn</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Break outer loop. Only reached if break was executed</span>
                <span class="c1"># in the inner loop.</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># All vertices are assigned the normal vector with</span>
                <span class="c1"># identical index. This is fine for mesh generation.</span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="p">[[</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">f</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">faces</span><span class="p">])</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">filename</span>

                <span class="k">return</span> <span class="n">mesh</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;rebuilding normal data block of &#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">CBOLD</span><span class="si">}{</span><span class="n">Path</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="si">}{</span><span class="n">CEND</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t\u251c\u2500</span><span class="s1"> </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;vn&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1"> normals read&#39;</span><span class="p">)</span>

            <span class="c1"># Fix the normals data block such that there are as many</span>
            <span class="c1"># normals as vertices and both blocks correponds by index.</span>
            <span class="c1"># If normal indices are not specified explicitly in face</span>
            <span class="c1"># definitions, none of this is executed!</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">faces</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">vn</span> <span class="ow">in</span> <span class="n">face</span><span class="p">:</span>
                    <span class="n">idx</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">vn</span><span class="p">)</span>

            <span class="c1"># The set idx[v] now holds all indices of normals assigned</span>
            <span class="c1"># to vertex v. If there there are multiple normals assigned</span>
            <span class="c1"># (allowed by OBJ specifications) they will be averaged.</span>
            <span class="n">block</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;vn&#39;</span><span class="p">]</span>
            <span class="n">normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">verts</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">num_avg</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">verts</span><span class="p">):</span>
                <span class="n">cluster</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">normals</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">)</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">normals</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">normals</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="p">:])</span>
                        <span class="n">num_avg</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">normals</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;vn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">normals</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t\u2514\u2500</span><span class="s1"> </span><span class="si">{</span><span class="n">num_avg</span><span class="si">}</span><span class="s1"> averages performed&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="p">[[</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">f</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">faces</span><span class="p">])</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">filename</span>

            <span class="k">return</span> <span class="n">mesh</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="p">[[</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">f</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">faces</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span></div>


<div class="viewcode-block" id="Mesh.write">
<a class="viewcode-back" href="../../api/m3sh.hds.Mesh.write.html#m3sh.hds.Mesh.write">[docs]</a>
    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Write mesh to file.</span>

<span class="sd">        Data arrays, like vertex normals and texture coordinates, can be</span>
<span class="sd">        saved by passing them as keyword arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            Name of an OBJ file.</span>
<span class="sd">        quiet : bool, optional</span>
<span class="sd">            Suppress console output.</span>
<span class="sd">        **data</span>
<span class="sd">            Arbitrary keyword arguments.</span>


<span class="sd">        User defined data blocks can be written with</span>

<span class="sd">        &gt;&gt;&gt; mesh.write(&#39;output-file.obj&#39;, line_tag=data)</span>

<span class="sd">        This assumes that ``data`` can be interpreted as a 2-dimensional</span>
<span class="sd">        array. The contents of each row are written to a line that starts</span>
<span class="sd">        with the given tag. If vertex normals are available, they can</span>
<span class="sd">        be stored via</span>

<span class="sd">        &gt;&gt;&gt; mesh.write(&#39;outfile-file.obj&#39;, vn=normals)</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The standard OBJ tags &#39;v&#39; and &#39;f&#39; may not be used as keywords</span>
<span class="sd">        since they are implicitly used when writing mesh data to an OBJ</span>
<span class="sd">        file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">CBOLD</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\33</span><span class="s1">[1m&#39;</span>                    <span class="c1"># bold text, white on black</span>
        <span class="n">CEND</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\33</span><span class="s1">[0m&#39;</span>

        <span class="k">if</span> <span class="s1">&#39;v&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;v&#39; may not be used as data tag&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;f&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;f&#39; may not be used as data tag&quot;</span><span class="p">)</span>

        <span class="n">vt_given</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">vn_given</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="s1">&#39;vt&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">vt</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;vt&#39;</span><span class="p">]</span>
            <span class="n">vt_given</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vt</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;number of texture vertices (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">vt</span><span class="p">)</span><span class="si">}</span><span class="s1">) != &#39;</span> <span class="o">+</span>
                       <span class="sa">f</span><span class="s1">&#39;number of vertices (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;vn&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">vn</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;vn&#39;</span><span class="p">]</span>
            <span class="n">vn_given</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vn</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;number of vertex normals (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">vn</span><span class="p">)</span><span class="si">}</span><span class="s1">) != &#39;</span> <span class="o">+</span>
                       <span class="sa">f</span><span class="s1">&#39;number of vertices (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">tidx</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">if</span> <span class="n">vt_given</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">nidx</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">if</span> <span class="n">vn_given</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># Using the implicit face iterator (instead of using self.faces</span>
        <span class="c1"># explicitly) will skip all faces of the mesh that are marked as</span>
        <span class="c1"># deleted.</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="p">(((</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">tidx</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">nidx</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;writing </span><span class="si">{</span><span class="n">CBOLD</span><span class="si">}{</span><span class="n">Path</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="si">}{</span><span class="n">CEND</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; ...&#39;</span><span class="p">)</span>

        <span class="c1"># Write all vertex coordinates (including unused/deleted/isolated)</span>
        <span class="c1"># ones. This is necessary since the faces list generated above</span>
        <span class="c1"># uses vertex offsets into the list of all vertices.</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">faces</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; done (</span><span class="si">{</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="si">:</span><span class="s1">.3</span><span class="si">}</span><span class="s1"> sec)&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Mesh.add_vertex">
<a class="viewcode-back" href="../../api/m3sh.hds.Mesh.add_vertex.html#m3sh.hds.Mesh.add_vertex">[docs]</a>
    <span class="k">def</span> <span class="nf">add_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Create and add new vertex.</span>

<span class="sd">        The first point added to a mesh determines the dimensionality</span>
<span class="sd">        of all mesh vertices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        point : array_like or float</span>
<span class="sd">            Vertex coordinates.</span>
<span class="sd">        *args</span>
<span class="sd">            Variable number of scalars.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Attribute name and value pairs.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `point` has the wrong shape.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Vertex</span>
<span class="sd">            The newly created :class:`Vertex` instance.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        When adding a new vertex all vertex data blocks are extended by</span>
<span class="sd">        a correponding value:</span>

<span class="sd">            - either by using the `default` value specified when</span>
<span class="sd">              the data block was added,</span>

<span class="sd">            - or by using a value provided as keyword argument.</span>

<span class="sd">        Values specified as keyword arguments that don&#39;t fit this pattern</span>
<span class="sd">        are added as :class:`Vertex` instance attributes and only availabe</span>
<span class="sd">        as attributes of this particular instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Append to (or create) the array of all vertex coordinates.</span>
        <span class="n">point</span> <span class="o">=</span> <span class="p">[</span><span class="n">point</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="k">else</span> <span class="n">point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_array_append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span>

        <span class="c1"># New vertex object that goes to the end of the list of all</span>
        <span class="c1"># vertices.</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">Vertex</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="p">),</span> <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_attr_values</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_vattr</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Attributes that are not managed via a corresponding mesh data</span>
        <span class="c1"># block become ordinary vertex instance attribute.</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># This calls the setter method of the property with the</span>
            <span class="c1"># name &#39;key&#39; if it exists.</span>
            <span class="c1"># if key not in (attr for _, attr, _ in self._vattr):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">v</span></div>


<div class="viewcode-block" id="Mesh.add_vertex_data">
<a class="viewcode-back" href="../../api/m3sh.hds.Mesh.add_vertex_data.html#m3sh.hds.Mesh.add_vertex_data">[docs]</a>
    <span class="k">def</span> <span class="nf">add_vertex_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Add vertex data.</span>

<span class="sd">        The `data` object has to allow access to vertex data using</span>
<span class="sd">        index notation. The data block as a whole can be accessed via</span>
<span class="sd">        ``self.name`` and the value ``data[v]`` as ``v.attr``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name of the data block.</span>
<span class="sd">        attr : str</span>
<span class="sd">            Name of vertex attribute.</span>
<span class="sd">        data : list or dict or ~numpy.ndarray</span>
<span class="sd">            Data object.</span>
<span class="sd">        default : object, optional</span>
<span class="sd">            Immutable default vertex attribute value.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If a data block of the same name already exists.</span>


<span class="sd">        To add a vector field (one vector per vertex) to a mesh we can</span>
<span class="sd">        do the following:</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">           :linenos:</span>

<span class="sd">            # Allocate data block of appropriate size and type.</span>
<span class="sd">            vecs = np.array_like(mesh.points)</span>

<span class="sd">            # Compute values for each vertex of the mesh.</span>
<span class="sd">            for v in mesh.vertices:</span>
<span class="sd">                vecs[v] = ...</span>

<span class="sd">            # Add the data block to the mesh. The vecs array can now be</span>
<span class="sd">            # accessed as mesh.vecs (we could have used any other name).</span>
<span class="sd">            mesh.add_vertex_data(&#39;vecs&#39;, &#39;vec&#39;, vecs)</span>
<span class="sd">            print(mesh.vecs is vecs)</span>

<span class="sd">            # Rows of the data block can now be accessed locally just</span>
<span class="sd">            # like the rows of the vertex coordinate array.</span>
<span class="sd">            for v in mesh.vertices:</span>
<span class="sd">                print(v.vec == vecs[v])</span>


<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        A mutable `default` value has the same drawbacks as mutable</span>
<span class="sd">        default function arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># self refers to a vertex instance</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="p">,</span> <span class="n">private_name</span><span class="p">)[</span><span class="bp">self</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># self refers to a mesh instance</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">private_name</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="p">,</span> <span class="n">private_name</span><span class="p">)[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">def</span> <span class="nf">set_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">private_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">del_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">data_name</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vattr</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">data_name</span> <span class="o">==</span> <span class="n">private_name</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vattr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">private_name</span><span class="p">)</span>

        <span class="c1"># The hidden name for direct access of the attribute data block.</span>
        <span class="c1"># Make sure not to unintentionally overwrite existing data.</span>
        <span class="n">private_name</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">name</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">private_name</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;data block &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; already exists&quot;</span><span class="p">)</span>

        <span class="c1"># if hasattr(Vertex, attr):</span>
        <span class="c1">#     raise ValueError(f&quot;vertex attribute &#39;{attr}&#39; already in use&quot;)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">private_name</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

        <span class="c1"># Store name and type of attribute. Memory management functions</span>
        <span class="c1"># need this information.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vattr</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">private_name</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">default</span><span class="p">))</span>

        <span class="c1"># Attribute access via properties. One global property bound to</span>
        <span class="c1"># the mesh and local properties bound to vertices.</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_data</span><span class="p">,</span> <span class="n">set_data</span><span class="p">,</span> <span class="n">del_data</span><span class="p">))</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">get</span><span class="p">,</span> <span class="nb">set</span><span class="p">))</span></div>


<div class="viewcode-block" id="Mesh.add_face">
<a class="viewcode-back" href="../../api/m3sh.hds.Mesh.add_face.html#m3sh.hds.Mesh.add_face">[docs]</a>
    <span class="k">def</span> <span class="nf">add_face</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">face</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Create and add new face.</span>

<span class="sd">        Vertex identifiers used in the definition of a face have to</span>
<span class="sd">        refer to existing vertices of the mesh.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        face : list[int] or list[Vertex]</span>
<span class="sd">            Combinatorial face definition.</span>
<span class="sd">        *args</span>
<span class="sd">            Variable number of :class:`Vertex` or :class:`int` arguments.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Attribute name and value pairs.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NonManifoldError</span>
<span class="sd">            If topological problems occur.</span>
<span class="sd">        IndexError</span>
<span class="sd">            If the given vertex indices are out of bounds.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given arguments do not define a valid face.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Face</span>
<span class="sd">            The newly created :class:`Face` instance.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        See :meth:`~Mesh.add_vertex` for a detailed discussion of `kwargs`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Number of vertices of the face, same as the number of edges</span>
        <span class="c1"># that bound the face.</span>
        <span class="n">face</span> <span class="o">=</span> <span class="p">[</span><span class="n">face</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="k">else</span> <span class="n">face</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">face</span><span class="p">)</span>

        <span class="c1"># Check for degeneracies: All vertices have to be topologically</span>
        <span class="c1"># different. If this test is passed there still need to be at</span>
        <span class="c1"># least three vertices. Duplicate coordinates are not a problem.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">face</span><span class="p">))</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;face contains duplicate vertices&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;face has less than three vertices&#39;</span><span class="p">)</span>

        <span class="c1"># Check consistency pre-conditions on vertex attributes. Failing</span>
        <span class="c1"># indicates an invalid halfedge data structure.</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="p">[</span><span class="n">face</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>

            <span class="k">assert</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">_deleted</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">v</span><span class="o">.</span><span class="n">_halfedge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">Face</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">))</span>          <span class="c1"># new face object</span>
        <span class="n">edge_loop</span> <span class="o">=</span> <span class="p">[]</span>                      <span class="c1"># halfedge loop around face</span>

        <span class="c1"># Dry run.</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="p">[</span><span class="n">face</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="p">[</span><span class="n">face</span><span class="p">[(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">]]</span>
            <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">h</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;edge (</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">_idx</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">w</span><span class="o">.</span><span class="n">_idx</span><span class="si">}</span><span class="s1">) is non-manifold&#39;</span>
                <span class="k">raise</span> <span class="n">NonManifoldError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># Add/process edges of the given face. The _add_halfedge method</span>
        <span class="c1"># may raise a NonManifoldError. If vertex indices are out of</span>
        <span class="c1"># bounds an IndexError is raised in the loop.</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="p">[</span><span class="n">face</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="p">[</span><span class="n">face</span><span class="p">[(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">]]</span>
            <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_halfedge</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>

            <span class="n">edge_loop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

        <span class="c1"># Proceed with linking mesh items together. The _pair attribute</span>
        <span class="c1"># of h was set by _add_halfedge if the pair was already mapped.</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">edge_loop</span><span class="p">:</span>
            <span class="n">h</span><span class="o">.</span><span class="n">_face</span> <span class="o">=</span> <span class="n">f</span>
            <span class="n">h</span><span class="o">.</span><span class="n">_origin</span><span class="o">.</span><span class="n">_halfedge</span> <span class="o">=</span> <span class="n">h</span>

            <span class="c1"># A halfedge should always have a pair. Create a boundary</span>
            <span class="c1"># edge if the pair does not exist yet.</span>
            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">_pair</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_halfedge</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">_target</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">_origin</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>               <span class="c1"># add face</span>
        <span class="n">f</span><span class="o">.</span><span class="n">_halfedge</span> <span class="o">=</span> <span class="n">edge_loop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>          <span class="c1"># set incident halfedge</span>

        <span class="c1"># Take care of next and prev halfedge pointer around the inner</span>
        <span class="c1"># edge loop of the face.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span>

            <span class="n">edge_loop</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="n">edge_loop</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">edge_loop</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">_prev</span> <span class="o">=</span> <span class="n">edge_loop</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># The interior edge loop of a face is already complete. We need to</span>
        <span class="c1"># take care of the outer loop. To do this we rely on the correctly</span>
        <span class="c1"># set pair pointers and prev/next pointers of the inner loop.</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">edge_loop</span><span class="p">:</span>
            <span class="n">ph</span> <span class="o">=</span> <span class="kc">None</span>                       <span class="c1"># previous halfedge, if any</span>
            <span class="n">hh</span> <span class="o">=</span> <span class="n">h</span>                          <span class="c1"># initialize iteration</span>

            <span class="c1"># Rotate the edge h = (v, w) as long as possible clockwise</span>
            <span class="c1"># around its origin v until we reach the boundary. There is</span>
            <span class="c1"># nothing to do if we circulate back to h itself.</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">hh</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ph</span> <span class="o">=</span> <span class="n">hh</span><span class="o">.</span><span class="n">_pair</span>
                    <span class="k">break</span>

                <span class="n">hh</span> <span class="o">=</span> <span class="n">hh</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_next</span>

                <span class="k">if</span> <span class="n">hh</span> <span class="ow">is</span> <span class="n">h</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="n">hh</span> <span class="o">=</span> <span class="n">h</span>                          <span class="c1"># reset iteration variable</span>

            <span class="c1"># If ph was set, halfedge h is now rotated counterclockwise</span>
            <span class="c1"># about its origin v until we reach the boundary.</span>
            <span class="k">while</span> <span class="n">ph</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">hh</span> <span class="o">=</span> <span class="n">hh</span><span class="o">.</span><span class="n">_prev</span><span class="o">.</span><span class="n">_pair</span>

                <span class="k">if</span> <span class="n">hh</span> <span class="ow">is</span> <span class="n">h</span><span class="p">:</span>
                    <span class="c1"># This branch should never be taken. There&#39;s no</span>
                    <span class="c1"># recovery from this problem.</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;vertex #</span><span class="si">{</span><span class="n">h</span><span class="o">.</span><span class="n">_origin</span><span class="o">.</span><span class="n">_idx</span><span class="si">}</span><span class="s1"> is non-manifold&#39;</span>
                    <span class="k">raise</span> <span class="n">NonManifoldError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">hh</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># We reached the boundary again. Link the halfedges.</span>
                    <span class="n">hh</span><span class="o">.</span><span class="n">_prev</span> <span class="o">=</span> <span class="n">ph</span>
                    <span class="n">ph</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="n">hh</span>

                    <span class="k">break</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_add_attr_values</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_fattr</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Attributes that are not managed via a corresponding mesh data</span>
        <span class="c1"># block become ordinary face instance attributes.</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># This calls the setter method of the property with the</span>
            <span class="c1"># name &#39;key&#39; if it exists, i.e., for managed attributes we</span>
            <span class="c1"># set the same value as done in the previous loop (could be</span>
            <span class="c1"># avoided with an if-condition).</span>
            <span class="c1"># if key not in (attr for _, attr, _ in self._fattr):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">f</span></div>


<div class="viewcode-block" id="Mesh.add_face_data">
<a class="viewcode-back" href="../../api/m3sh.hds.Mesh.add_face_data.html#m3sh.hds.Mesh.add_face_data">[docs]</a>
    <span class="k">def</span> <span class="nf">add_face_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Add face data.</span>

<span class="sd">        The `data` object has to allow access to face data using</span>
<span class="sd">        index notation. The data block as a whole can be accessed via</span>
<span class="sd">        ``self.name`` and the value ``data[f]`` as ``f.attr``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name of the data block.</span>
<span class="sd">        attr : str</span>
<span class="sd">            Name of face attribute.</span>
<span class="sd">        data : list or dict or ~numpy.ndarray</span>
<span class="sd">            Data object.</span>
<span class="sd">        default : object, optional</span>
<span class="sd">            Immutable default face attribute value.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If a data block of the same name already exists.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        See :meth:`~Mesh.add_vertex_data` for an example.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># self refers to a face instance</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span><span class="o">.</span><span class="n">_origin</span><span class="o">.</span><span class="n">_mesh</span><span class="p">,</span> <span class="n">private_name</span><span class="p">)[</span><span class="bp">self</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># self refers to a mesh instance</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">private_name</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span><span class="o">.</span><span class="n">_origin</span><span class="o">.</span><span class="n">_mesh</span><span class="p">,</span> <span class="n">private_name</span><span class="p">)[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">def</span> <span class="nf">set_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">private_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">del_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">data_name</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fattr</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">data_name</span> <span class="o">==</span> <span class="n">private_name</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fattr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">private_name</span><span class="p">)</span>

        <span class="c1"># The hidden name for direct access of the attribute data block.</span>
        <span class="c1"># Make sure to not unintentionally overwrite existing data.</span>
        <span class="n">private_name</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">name</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">private_name</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;data block &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; already exists&quot;</span><span class="p">)</span>

        <span class="c1"># if hasattr(Face, attr):</span>
        <span class="c1">#     raise ValueError(f&quot;face attribute &#39;{attr}&#39; already in use&quot;)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">private_name</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

        <span class="c1"># Store name and type of attribute. Memory management functions</span>
        <span class="c1"># need this information.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fattr</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">private_name</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">default</span><span class="p">))</span>

        <span class="c1"># Attribute access via properties. One global property bound to</span>
        <span class="c1"># the mesh and local properties bound to faces.</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_data</span><span class="p">,</span> <span class="n">set_data</span><span class="p">,</span> <span class="n">del_data</span><span class="p">))</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">Face</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">get</span><span class="p">,</span> <span class="nb">set</span><span class="p">))</span></div>


<div class="viewcode-block" id="Mesh.add_halfedge_data">
<a class="viewcode-back" href="../../api/m3sh.hds.Mesh.add_halfedge_data.html#m3sh.hds.Mesh.add_halfedge_data">[docs]</a>
    <span class="k">def</span> <span class="nf">add_halfedge_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Add halfedge data.</span>

<span class="sd">        The `data` object has to allow access to halfedge data using</span>
<span class="sd">        index notation. The data block as a whole can be accessed via</span>
<span class="sd">        ``self.name`` and the value ``data[h]`` as ``h.attr``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name of the data block.</span>
<span class="sd">        attr : str</span>
<span class="sd">            Name of halfedge attribute.</span>
<span class="sd">        data : dict</span>
<span class="sd">            Data object.</span>
<span class="sd">        default : object, optional</span>
<span class="sd">            Immutable default halfedge attribute value.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If a data block of same name already exists or the</span>
<span class="sd">            data block is not a dictionary instance.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        See :meth:`~Mesh.add_vertex_data` for an example.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;data block has to be of type &#39;dict&#39;&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># self refers to a halfedge instance</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin</span><span class="o">.</span><span class="n">_mesh</span><span class="p">,</span> <span class="n">private_name</span><span class="p">)[</span><span class="bp">self</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># self refers to a mesh instance</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">private_name</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin</span><span class="o">.</span><span class="n">_mesh</span><span class="p">,</span> <span class="n">private_name</span><span class="p">)[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">def</span> <span class="nf">set_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">private_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">del_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">data_name</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hattr</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">data_name</span> <span class="o">==</span> <span class="n">private_name</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hattr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">private_name</span><span class="p">)</span>

        <span class="c1"># The hidden name for direct access of the attribute data block.</span>
        <span class="c1"># Make sure not to unintentionally overwrite existing data.</span>
        <span class="n">private_name</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">name</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">private_name</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;data block &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; already exists&quot;</span><span class="p">)</span>

        <span class="c1"># if hasattr(Halfedge, attr):</span>
        <span class="c1">#     raise ValueError(f&quot;halfedge attribute &#39;{attr}&#39; already in use&quot;)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">private_name</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

        <span class="c1"># Store name and type of attribute. Memory management functions</span>
        <span class="c1"># need this information.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hattr</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">private_name</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">default</span><span class="p">))</span>

        <span class="c1"># Attribute access via properties. One global property bound to</span>
        <span class="c1"># the mesh and local properties bound to halfedges.</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_data</span><span class="p">,</span> <span class="n">set_data</span><span class="p">,</span> <span class="n">del_data</span><span class="p">))</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">Halfedge</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">get</span><span class="p">,</span> <span class="nb">set</span><span class="p">))</span></div>


<div class="viewcode-block" id="Mesh.clear">
<a class="viewcode-back" href="../../api/m3sh.hds.Mesh.clear.html#m3sh.hds.Mesh.clear">[docs]</a>
    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Clear all mesh items.</span>

<span class="sd">        The memory occupied by the coordinate array is garbage collected</span>
<span class="sd">        once no further references or views of it remain.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Data blocks are cleared by calling the data block&#39;s own</span>
<span class="sd">        :func:`~object.clear` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Lists and dictionary attributes are cleared in place instead of</span>
        <span class="c1"># resetting them to a new empty container.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vattr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hattr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fattr</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">attr</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">_array_clear</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="Mesh.clean">
<a class="viewcode-back" href="../../api/m3sh.hds.Mesh.clean.html#m3sh.hds.Mesh.clean">[docs]</a>
    <span class="k">def</span> <span class="nf">clean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Garbage collection.</span>

<span class="sd">        Removes all deleted mesh items from the respective containers.</span>
<span class="sd">        Previously obtained vertex and face indices may become invalid.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Use sparingly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">shrink</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">items</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">item</span><span class="o">.</span><span class="n">_deleted</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">_deleted</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="c1"># The first assignment has no effect on data for an empty</span>
                <span class="c1"># list of indices, resize will then set the length of the</span>
                <span class="c1"># first axis of data to zero.</span>
                <span class="n">data</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
                <span class="n">data</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">refcheck</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Invalidate all attributes of vertices to be removed from the mesh.</span>
        <span class="c1"># This should prevent accidental access by triggering assertions and</span>
        <span class="c1"># raising exceptions by references outside the mesh instance.</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">_deleted</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                <span class="n">v</span><span class="o">.</span><span class="n">_invalidate</span><span class="p">()</span>

        <span class="c1"># Find the indices of vertices *not* marked for deletion. Calculate</span>
        <span class="c1"># the shape of the compressed coordinate array.</span>
        <span class="n">vidx</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">_deleted</span><span class="p">]</span>
        <span class="n">fidx</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">_deleted</span><span class="p">]</span>

        <span class="c1"># Move the coordinates of live vertices to the front of the point</span>
        <span class="c1"># array, preserving their relative order. Then compress the array</span>
        <span class="c1"># by in-place resizing.</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vidx</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vidx</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">vidx</span><span class="p">),</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="n">vidx</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">refcheck</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Attribute data blocks have to be rearranged before changing the</span>
        <span class="c1"># corresponding mesh item container!</span>
        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">items</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_vattr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hattr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fattr</span><span class="p">),</span>
                                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">),</span>
                                    <span class="p">(</span><span class="n">vidx</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">fidx</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">attr</span><span class="p">:</span>
                <span class="c1"># The nested shrink method relies on the shape variable</span>
                <span class="c1"># set earlier.</span>
                <span class="n">shrink</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span> <span class="n">items</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

        <span class="c1"># Update vertex container to skip all unused vertices. Update all</span>
        <span class="c1"># vertex indices afterwards.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">_deleted</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="p">):</span>
            <span class="n">v</span><span class="o">.</span><span class="n">_idx</span> <span class="o">=</span> <span class="n">i</span>

        <span class="c1"># Remove deleted halfedges from the halfedge container. Invalidate</span>
        <span class="c1"># all their attributes.</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">_deleted</span><span class="p">:</span>
                <span class="c1"># This should never be reached. By design there should</span>
                <span class="c1"># not be any halfedges marked as deleted in the dictionary.</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;halfedge structure seems corrupt&#39;</span><span class="p">)</span>

                <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="n">h</span><span class="o">.</span><span class="n">_invalidate</span><span class="p">()</span>

        <span class="c1"># Invalidate all attributes of faces to be removed from the mesh.</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">_deleted</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">_invalidate</span><span class="p">()</span>

        <span class="c1"># Update face container to skip all unwanted faces. Afterwards</span>
        <span class="c1"># update all face indices.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">_deleted</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">_idx</span> <span class="o">=</span> <span class="n">i</span></div>


<div class="viewcode-block" id="Mesh.clone">
<a class="viewcode-back" href="../../api/m3sh.hds.Mesh.clone.html#m3sh.hds.Mesh.clone">[docs]</a>
    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; In-place mesh copy.</span>

<span class="sd">        Implements assignment operator like behavior. Performs the same</span>
<span class="sd">        operation as :meth:`copy` but assigns the result to the mesh</span>
<span class="sd">        instance `self`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mesh : Mesh</span>
<span class="sd">            Source mesh.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">dict_copy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">map</span><span class="p">):</span>
            <span class="c1"># The map argument provides a mapping of keys. Mapped values</span>
            <span class="c1"># are just assigned and not copied.</span>
            <span class="n">data_copy</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># This could be used to make copies of ndarrays stored</span>
                <span class="c1"># as dictionary values -- but makes copy() inconsistent.</span>
                <span class="n">data_copy</span><span class="p">[</span><span class="nb">map</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>

            <span class="k">return</span> <span class="n">data_copy</span>

        <span class="n">vmap</span><span class="p">,</span> <span class="n">hmap</span><span class="p">,</span> <span class="n">fmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone_connectivity_from</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

        <span class="c1"># Since _points is of type ndarray, this is a deep copy, i.e. no</span>
        <span class="c1"># parts of the vertex coordinate data buffers are shared.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Clear data blocks in the target mesh. Some of them may have already</span>
        <span class="c1"># been removed from the source mesh.</span>
        <span class="k">for</span> <span class="n">attr_type</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vattr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hattr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fattr</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">private_name</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">attr_type</span><span class="p">:</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">private_name</span><span class="p">)</span>

        <span class="c1"># Shallow copies of lists that hold tuples (immutable, no point</span>
        <span class="c1"># making a deep copy).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vattr</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">_vattr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hattr</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">_hattr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fattr</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">_fattr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Copy all data blocks. Shallow copies, except for ndarray, custom</span>
        <span class="c1"># method to handle dictionary copies.</span>
        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="nb">map</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">((</span><span class="n">mesh</span><span class="o">.</span><span class="n">_vattr</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">_hattr</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">_fattr</span><span class="p">),</span>
                             <span class="p">(</span><span class="n">vmap</span><span class="p">,</span> <span class="n">hmap</span><span class="p">,</span> <span class="n">fmap</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">private_name</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">attr</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">private_name</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">private_name</span><span class="p">,</span> <span class="n">dict_copy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">map</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">private_name</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Mesh.copy">
<a class="viewcode-back" href="../../api/m3sh.hds.Mesh.copy.html#m3sh.hds.Mesh.copy">[docs]</a>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return mesh copy.</span>

<span class="sd">        Duplicate combinatorics, vertex coordinates, and data blocks of a</span>
<span class="sd">        mesh. Data blocks are copied using the data object&#39;s</span>
<span class="sd">        :meth:`~object.copy` method. For data blocks of type :class:`list`</span>
<span class="sd">        and :class:`dict` this results in shallow copies. Data of type</span>
<span class="sd">        :class:`~numpy.ndarray` won&#39;t share data buffers with data blocks</span>
<span class="sd">        of the copy.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Mesh</span>
<span class="sd">            Copy of the mesh.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        User defined vertex, face, and halfedge instance attributes are</span>
<span class="sd">        copied using :func:`copy.copy`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="Mesh.delete_vertex">
<a class="viewcode-back" href="../../api/m3sh.hds.Mesh.delete_vertex.html#m3sh.hds.Mesh.delete_vertex">[docs]</a>
    <span class="k">def</span> <span class="nf">delete_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Delete vertex.</span>

<span class="sd">        Delete vertex and optionally fill the formed hole.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vertex : Vertex or int</span>
<span class="sd">            Vertex identifier.</span>
<span class="sd">        fill : str, optional</span>
<span class="sd">            Pass &#39;tri&#39; to triangulate the hole or &#39;ngon&#39;</span>
<span class="sd">            to turn it into a polygonal face.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NonManifoldError</span>
<span class="sd">            If vertex deletion was not possible.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Face or list[Face]</span>
<span class="sd">            The faces used to patch the hole. :obj:`None` if hole</span>
<span class="sd">            filling was not requested.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">_deleted</span>

        <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">isolated</span><span class="p">:</span>
            <span class="n">v</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">_manifold</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fill</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">NonManifoldError</span><span class="p">(</span><span class="s1">&#39;cannot fill hole formed by &#39;</span> <span class="o">+</span>
                                       <span class="s1">&#39;deleting a non-manifold vertex&#39;</span><span class="p">)</span>

            <span class="c1"># Collect all faces incident with vertex v. Use _vhout[v] to</span>
            <span class="c1"># to treat non-manifold vertices correctly.</span>
            <span class="n">faces</span> <span class="o">=</span> <span class="p">[</span><span class="n">h</span><span class="o">.</span><span class="n">face</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">face</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">faces</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delete_face</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">del_isolated_verts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">boundary</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">boundary</span>

            <span class="k">while</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">_deleted</span><span class="p">:</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">_halfedge</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">face</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">pair</span><span class="o">.</span><span class="n">face</span>

                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="nb">next</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">next</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">delete_halfedge</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">del_isolated_verts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                    <span class="k">if</span> <span class="nb">next</span><span class="o">.</span><span class="n">face</span> <span class="ow">is</span> <span class="n">left</span> <span class="ow">and</span> <span class="nb">next</span><span class="o">.</span><span class="n">pair</span><span class="o">.</span><span class="n">face</span> <span class="ow">is</span> <span class="n">right</span><span class="p">:</span>
                        <span class="n">h</span> <span class="o">=</span> <span class="nb">next</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">break</span>

            <span class="k">if</span> <span class="n">fill</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">boundary</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">delete_face</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">del_isolated_verts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">boundary</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">fill</span> <span class="o">==</span> <span class="s1">&#39;tri&#39;</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;fill method missing&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;fill method missing&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Mesh.delete_face">
<a class="viewcode-back" href="../../api/m3sh.hds.Mesh.delete_face.html#m3sh.hds.Mesh.delete_face">[docs]</a>
    <span class="k">def</span> <span class="nf">delete_face</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">face</span><span class="p">,</span> <span class="n">del_isolated_verts</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Delete face.</span>

<span class="sd">        Vertices of `face` rendered isolated by the combinatorial face</span>
<span class="sd">        removal can be kept as isolated vertices or be marked as deleted.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        face : Face or int</span>
<span class="sd">            Face identifier.</span>
<span class="sd">        del_isolated_verts : bool, optional</span>
<span class="sd">            Mark isolated vertices for deletion.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The deleted face is not removed from the mesh&#39;s face container</span>
<span class="sd">        immediately. It is marked as deleted and removed from the face</span>
<span class="sd">        container when calling :meth:`clean`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">[</span><span class="n">face</span><span class="p">]</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">_deleted</span>

        <span class="c1"># Get halfedges bordering the face. Nothing to do for an empty</span>
        <span class="c1"># face.</span>
        <span class="n">edge_loop</span> <span class="o">=</span> <span class="p">[</span><span class="n">h</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">_hiter</span><span class="p">()]</span>

        <span class="c1"># A boundary face gets merged with the adjacent boundary component.</span>
        <span class="c1"># Halfedges that connect the face with the boundary are deleted.</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">edge_loop</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">h</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_face</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delete_halfedge</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">del_isolated_verts</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">h</span><span class="o">.</span><span class="n">_face</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Finally mark the face as deleted.</span>
        <span class="n">f</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="Mesh.delete_halfedge">
<a class="viewcode-back" href="../../api/m3sh.hds.Mesh.delete_halfedge.html#m3sh.hds.Mesh.delete_halfedge">[docs]</a>
    <span class="k">def</span> <span class="nf">delete_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">halfedge</span><span class="p">,</span> <span class="n">del_isolated_verts</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Merge adjacent faces.</span>

<span class="sd">        Merges the incident faces of an edge. Merging across a boundary</span>
<span class="sd">        edge will delete the incident non-boundary face. Vertices of</span>
<span class="sd">        `halfedge` rendered isolated by the change in mesh combinatorics</span>
<span class="sd">        can be kept as isolated vertices or be marked as deleted.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        halfedge : Halfedge</span>
<span class="sd">            The halfedge that spans the edge to be deleted.</span>
<span class="sd">        del_isolated_verts : bool, optional</span>
<span class="sd">            Mark isolated vertices for deletion.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NonManifoldError</span>
<span class="sd">            If the operation leads to invalid combinatorics.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Face</span>
<span class="sd">            The merged face or :obj:`None` when merging across the</span>
<span class="sd">            boundary. For interior `halfedge`, this is equal to the</span>
<span class="sd">            face to its right.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This operation may create *dangling (half)edges*, i.e., halfedges</span>
<span class="sd">        where ``h.pair`` equals ``h.next``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_deleted</span>

        <span class="c1"># If halfedge is a boundary halfedge we replace it with its pair</span>
        <span class="c1"># if this is not at the boundary. In case of dangling edges both</span>
        <span class="c1"># halfedges can be boundary halfedges.</span>
        <span class="k">if</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">halfedge</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span>

        <span class="c1"># The face to the left of halfedge gets merged with the face to</span>
        <span class="c1"># the right. Neither halfedge nor its pair may be used as the</span>
        <span class="c1"># halfedge attribute of this face.</span>
        <span class="k">if</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># This path is only taken if neither halfedge nor its pair</span>
            <span class="c1"># are boundary halfedges.</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_face</span><span class="o">.</span><span class="n">_halfedge</span>

            <span class="c1"># Walk around the right hand side face and try to find an</span>
            <span class="c1"># alternative value for its halfedge attribute.</span>
            <span class="k">while</span> <span class="n">h</span> <span class="ow">is</span> <span class="n">halfedge</span> <span class="ow">or</span> <span class="n">h</span> <span class="ow">is</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="p">:</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_next</span>

                <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_face</span><span class="o">.</span><span class="n">_halfedge</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="c1"># If no alternative was found there is no way to continue</span>
            <span class="c1"># without corrupting the halfedge data structure.</span>
            <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="n">halfedge</span> <span class="ow">or</span> <span class="n">h</span> <span class="ow">is</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">NonManifoldError</span><span class="p">(</span><span class="s1">&#39;halfedge deletion failed&#39;</span><span class="p">)</span>

            <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_face</span><span class="o">.</span><span class="n">_halfedge</span> <span class="o">=</span> <span class="n">h</span>

        <span class="c1"># Make sure that the deleted halfedge is not stored as the</span>
        <span class="c1"># outgoing halfedge of its origin.</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_origin</span>

        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">halfedge</span><span class="p">:</span>
                <span class="n">v</span><span class="o">.</span><span class="n">_halfedge</span> <span class="o">=</span> <span class="n">h</span>
                <span class="k">break</span>

        <span class="c1"># If no alternative outgoing halfedge could be found, vertex v</span>
        <span class="c1"># is a dangling vertex and becomes unused after the halfedge is</span>
        <span class="c1"># removed.</span>
        <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">_halfedge</span> <span class="ow">is</span> <span class="n">halfedge</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">del_isolated_verts</span><span class="p">:</span>
                <span class="n">v</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span><span class="o">.</span><span class="n">_halfedge</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Perform the same steps for halfedge.pair since this will also</span>
        <span class="c1"># get removed.</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_origin</span>

        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="p">:</span>
                <span class="n">w</span><span class="o">.</span><span class="n">_halfedge</span> <span class="o">=</span> <span class="n">h</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">w</span><span class="o">.</span><span class="n">_halfedge</span> <span class="ow">is</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">del_isolated_verts</span><span class="p">:</span>
                <span class="n">w</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">w</span><span class="o">.</span><span class="n">_halfedge</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># The face that survives the merge operation. Can be None if a</span>
        <span class="c1"># boundary face gets deleted by the merge.</span>
        <span class="n">face</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_face</span>

        <span class="c1"># The two faces indicent with halfedge get merged. If they are</span>
        <span class="c1"># equal the deleted halfedge is a dangling edge.</span>
        <span class="k">if</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_face</span><span class="p">:</span>
            <span class="n">halfedge</span><span class="o">.</span><span class="n">_face</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_next</span>

            <span class="c1"># All halfedges of the face to the left get assgined to</span>
            <span class="c1"># the face on the right hand side of the halfedge. We do</span>
            <span class="c1"># not change attributes of halfedge itself.</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">h</span><span class="o">.</span><span class="n">_face</span> <span class="o">=</span> <span class="n">face</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_next</span>

                <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="n">halfedge</span><span class="p">:</span>
                    <span class="k">break</span>

        <span class="c1"># Remove the pair of halfedges from face defining halfedge loops.</span>
        <span class="c1"># Then pop from the halfedge dictionary.</span>
        <span class="n">halfedge</span><span class="o">.</span><span class="n">_prev</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_next</span>
        <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_next</span><span class="o">.</span><span class="n">_prev</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_prev</span>

        <span class="n">halfedge</span><span class="o">.</span><span class="n">_next</span><span class="o">.</span><span class="n">_prev</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_prev</span>
        <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_prev</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_next</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_pop_halfedge</span><span class="p">(</span><span class="n">halfedge</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pop_halfedge</span><span class="p">(</span><span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="p">)</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">_deleted</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">w</span><span class="o">.</span><span class="n">_deleted</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>

        <span class="k">assert</span> <span class="n">v</span><span class="o">.</span><span class="n">_halfedge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">w</span><span class="o">.</span><span class="n">_halfedge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">face</span></div>


<div class="viewcode-block" id="Mesh.collapse_halfedge">
<a class="viewcode-back" href="../../api/m3sh.hds.Mesh.collapse_halfedge.html#m3sh.hds.Mesh.collapse_halfedge">[docs]</a>
    <span class="k">def</span> <span class="nf">collapse_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">halfedge</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">del_target</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                          <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Perform edge collapse.</span>

<span class="sd">        Collapse `halfedge` into its :attr:`~Halfedge.origin` vertex. By</span>
<span class="sd">        default, the :attr:`~Halfedge.target` vertex of `halfedge` is</span>
<span class="sd">        marked as deleted but it can also be kept as an isolated vertex.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        halfedge : Halfedge</span>
<span class="sd">            Halfedge to be contracted.</span>
<span class="sd">        point : array_like, optional</span>
<span class="sd">            Coordinates of collapse location.</span>
<span class="sd">        del_target : bool, optional</span>
<span class="sd">            Mark target vertex as deleted.</span>
<span class="sd">        check : bool, optional</span>
<span class="sd">            Pass :obj:`False` to skip collapsibility test.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `halfedge` is a boundary halfedge.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Vertex</span>
<span class="sd">            Reference to the :attr:`~Halfedge.origin` of `halfedge` or</span>
<span class="sd">            :obj:`None` in case of failure (the latter behavior requires</span>
<span class="sd">            ``check=True``).</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        It is assumed that the applicability of an edge collapse has been</span>
<span class="sd">        checked for explicitly via :attr:`~Halfedge.collapsible` when</span>
<span class="sd">        skipping the test.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">prepare_he_loop</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">set_origin_halfedge</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="c1"># The length of a face defining loop of halfedges. For a</span>
            <span class="c1"># boundary halfedge this is the length of the boundary.</span>
            <span class="n">loop_len</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_compute_loop_len</span><span class="p">()</span>

            <span class="c1"># If the face to the left is a triangle it will disappear</span>
            <span class="c1"># during the halfedge collapse operation.</span>
            <span class="k">if</span> <span class="n">loop_len</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1"># There has to be a face, otherwise the edge cannot be</span>
                <span class="c1"># collapsed because of topological problems.</span>
                <span class="n">h</span><span class="o">.</span><span class="n">_face</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># The vertex opposite the halfedge. Ensure its outgoing</span>
                <span class="c1"># halfedge is valid after the collapse.</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_next</span><span class="o">.</span><span class="n">_target</span>
                <span class="n">v</span><span class="o">.</span><span class="n">_halfedge</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_next</span><span class="o">.</span><span class="n">_pair</span>

                <span class="c1"># Remove halfedges of the interior edge loop from the</span>
                <span class="c1"># halfedge container.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pop_halfedge</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">_prev</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pop_halfedge</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">_next</span><span class="p">)</span>

            <span class="c1"># Lazy property management. This could go inside an else</span>
            <span class="c1"># block (no effect for triangular faces).</span>
            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">h</span><span class="o">.</span><span class="n">_face</span><span class="o">.</span><span class="n">_valence</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># Remove halfedge from halfedge dictionary. Sets its status</span>
            <span class="c1"># to deleted.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pop_halfedge</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

            <span class="c1"># Ensure the outgoing halfedges of origin stays valid after</span>
            <span class="c1"># the halfedge is collapsed.</span>
            <span class="k">if</span> <span class="n">set_origin_halfedge</span><span class="p">:</span>
                <span class="n">h</span><span class="o">.</span><span class="n">_origin</span><span class="o">.</span><span class="n">_halfedge</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_prev</span><span class="o">.</span><span class="n">_pair</span>

            <span class="k">return</span> <span class="n">loop_len</span>

        <span class="k">def</span> <span class="nf">glue_he_faces</span><span class="p">(</span><span class="n">h</span><span class="p">):</span>
            <span class="c1"># Glue previous and next halfedge of an edge of a triangle.</span>
            <span class="n">h</span><span class="o">.</span><span class="n">_prev</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_pair</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_next</span><span class="o">.</span><span class="n">_pair</span>
            <span class="n">h</span><span class="o">.</span><span class="n">_next</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_pair</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_prev</span><span class="o">.</span><span class="n">_pair</span>

        <span class="c1"># Early exit if halfedge cannot be collapsed. Return None value to</span>
        <span class="c1"># signal failure.</span>
        <span class="k">if</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_deleted</span> <span class="ow">or</span> <span class="p">(</span><span class="n">check</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">collapsible</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;boundary halfedge cannot be collapsed - &#39;</span> <span class="o">+</span>
                             <span class="s1">&#39;use its pair&#39;</span><span class="p">)</span>

        <span class="n">lt_len</span> <span class="o">=</span> <span class="n">prepare_he_loop</span><span class="p">(</span><span class="n">halfedge</span><span class="p">)</span>
        <span class="n">rt_len</span> <span class="o">=</span> <span class="n">prepare_he_loop</span><span class="p">(</span><span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="p">,</span> <span class="n">set_origin_halfedge</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">origin</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_origin</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_target</span>

        <span class="c1"># All halfedges starting at target now start at origin. The target</span>
        <span class="c1"># vertex itself will be unused after the collapse is complete.</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">_hiter</span><span class="p">():</span>
            <span class="c1"># Do not modify combinatorial attributes of halfedges that are</span>
            <span class="c1"># no longer used by the new mesh. This makes it easy to undo a</span>
            <span class="c1"># halfedge collapse operation later.</span>
            <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">lt_len</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_next</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_set_origin</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">rt_len</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">h</span><span class="o">.</span><span class="n">_pair</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_prev</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_set_target</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">_pair</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>

        <span class="c1"># Now either glue two halfedges together to delete a neighboring</span>
        <span class="c1"># triangle or skip a halfedge if case of larger face valence.</span>
        <span class="k">if</span> <span class="n">lt_len</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">glue_he_faces</span><span class="p">(</span><span class="n">halfedge</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">halfedge</span><span class="o">.</span><span class="n">_prev</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_next</span>
            <span class="n">halfedge</span><span class="o">.</span><span class="n">_next</span><span class="o">.</span><span class="n">_prev</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_prev</span>

        <span class="k">if</span> <span class="n">rt_len</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">glue_he_faces</span><span class="p">(</span><span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_prev</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_next</span>
            <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_next</span><span class="o">.</span><span class="n">_prev</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_prev</span>

        <span class="c1"># The target vertex is now disconnected from the mesh. Keep it</span>
        <span class="c1"># as isolated vertex or mark it for deletion.</span>
        <span class="k">if</span> <span class="n">del_target</span><span class="p">:</span>
            <span class="c1"># Mark target vertex as deleted. Note that the vertex keeps</span>
            <span class="c1"># its outgoing halfedge.</span>
            <span class="n">halfedge</span><span class="o">.</span><span class="n">_target</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">halfedge</span><span class="o">.</span><span class="n">_target</span><span class="o">.</span><span class="n">_halfedge</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># For consistency of the hds state, the set of outgoing halfedges</span>
        <span class="c1"># has to be empty, no matter if we mark it as deleted or not.</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">halfedge</span><span class="o">.</span><span class="n">_target</span><span class="p">]</span>

        <span class="c1"># Move vertex v to its new location. Can raise ValueError if</span>
        <span class="c1"># point could not be broadcast to the correct point shape.</span>
        <span class="k">if</span> <span class="n">point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">halfedge</span><span class="o">.</span><span class="n">_origin</span><span class="o">.</span><span class="n">point</span> <span class="o">=</span> <span class="n">point</span>

        <span class="k">return</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_origin</span></div>


<div class="viewcode-block" id="Mesh.flip_halfedge">
<a class="viewcode-back" href="../../api/m3sh.hds.Mesh.flip_halfedge.html#m3sh.hds.Mesh.flip_halfedge">[docs]</a>
    <span class="k">def</span> <span class="nf">flip_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">halfedge</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Flip halfedge.</span>

<span class="sd">        Only halfedges incident to triangular faces can be flipped.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        halfedge : Halfedge</span>
<span class="sd">            The halfedge to be flipped.</span>
<span class="sd">        check : bool, optional</span>
<span class="sd">            Pass :obj:`False` to skip flippability test.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Halfedge</span>
<span class="sd">            The halfedge resulting from the edge flip or :obj:`None` in</span>
<span class="sd">            case of failure (the latter behavior requires ``check=True``).</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        It is assumed that the applicability of an edge flip has been checked</span>
<span class="sd">        explicitly via :attr:`~Halfedge.flippable` when skipping the test.</span>
<span class="sd">        Unchecked edge flipping results in undefined behavior.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_deleted</span> <span class="ow">or</span> <span class="p">(</span><span class="n">check</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">flippable</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">v</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_next</span><span class="o">.</span><span class="n">_target</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_next</span><span class="o">.</span><span class="n">_target</span>

        <span class="c1"># This is an extra test layer. The flippable method of a halfedge</span>
        <span class="c1"># should have flagged such an edge as non-flippable.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">origin</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_origin</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_target</span>

        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_next</span><span class="p">,</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_prev</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_next</span><span class="p">,</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_prev</span>

        <span class="c1"># Unconditional re-assignment of halfedge attributes. This is not</span>
        <span class="c1"># always necessary and could be turned in a conditional assignment.</span>
        <span class="n">origin</span><span class="o">.</span><span class="n">_halfedge</span> <span class="o">=</span> <span class="n">c</span>
        <span class="n">target</span><span class="o">.</span><span class="n">_halfedge</span> <span class="o">=</span> <span class="n">a</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_vertices</span><span class="p">(</span><span class="n">halfedge</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_vertices</span><span class="p">(</span><span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>

        <span class="n">halfedge</span><span class="o">.</span><span class="n">_next</span><span class="p">,</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_prev</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span>
        <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_next</span><span class="p">,</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_prev</span> <span class="o">=</span> <span class="n">d</span><span class="p">,</span> <span class="n">a</span>

        <span class="n">a</span><span class="o">.</span><span class="n">_next</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">_prev</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="p">,</span> <span class="n">d</span>
        <span class="n">d</span><span class="o">.</span><span class="n">_next</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">_prev</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span>

        <span class="n">b</span><span class="o">.</span><span class="n">_next</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">_prev</span> <span class="o">=</span> <span class="n">c</span><span class="p">,</span> <span class="n">halfedge</span>
        <span class="n">c</span><span class="o">.</span><span class="n">_next</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">_prev</span> <span class="o">=</span> <span class="n">halfedge</span><span class="p">,</span> <span class="n">b</span>

        <span class="n">a</span><span class="o">.</span><span class="n">_face</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_face</span>
        <span class="n">c</span><span class="o">.</span><span class="n">_face</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_face</span>

        <span class="n">halfedge</span><span class="o">.</span><span class="n">_face</span><span class="o">.</span><span class="n">_halfedge</span> <span class="o">=</span> <span class="n">halfedge</span>
        <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_face</span><span class="o">.</span><span class="n">_halfedge</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span>

        <span class="k">return</span> <span class="n">halfedge</span></div>


<div class="viewcode-block" id="Mesh.insert_halfedge">
<a class="viewcode-back" href="../../api/m3sh.hds.Mesh.insert_halfedge.html#m3sh.hds.Mesh.insert_halfedge">[docs]</a>
    <span class="k">def</span> <span class="nf">insert_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">face</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Insert face diagonal.</span>

<span class="sd">        Splits `face` into two polygonal parts.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        face : Face</span>
<span class="sd">            Polygonal face of a mesh.</span>
<span class="sd">        origin : Vertex</span>
<span class="sd">            Origin vertex, incident with `face`.</span>
<span class="sd">        target : Vertex</span>
<span class="sd">            Target vertex, incident with `face` and</span>
<span class="sd">            different from `origin`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            In case of invalid input.</span>
<span class="sd">        NonManifoldError</span>
<span class="sd">            If something goes wrong.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Halfedge</span>
<span class="sd">            The newly inserted halfedge. The face to its left is equal</span>
<span class="sd">            to `face`.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This method cannot be used to split off parts of a mesh&#39;s</span>
<span class="sd">        boundary. Use :meth:`~Mesh.add_face` for that.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">face</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;origin vertex </span><span class="si">{</span><span class="n">origin</span><span class="si">}</span><span class="s1"> is no vertex of </span><span class="si">{</span><span class="n">face</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">face</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;target vertex </span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s1"> is no vertex of </span><span class="si">{</span><span class="n">face</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;halfedge (</span><span class="si">{</span><span class="n">origin</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s1">) already exists&#39;</span>
            <span class="k">raise</span> <span class="n">NonManifoldError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;halfedge vertices have to be different&#39;</span>
            <span class="k">raise</span> <span class="n">NonManifoldError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># Create and add two new halfedges to the halfedge container.</span>
        <span class="c1"># This will establish the halfedges pair pointers.</span>
        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_halfedge</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="n">hbar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_halfedge</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>

        <span class="c1"># Find the next and previous halfedges of h and hbar among the</span>
        <span class="c1"># existing halfeges of face.</span>
        <span class="n">h_next</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">h</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">face</span><span class="o">.</span><span class="n">_hiter</span><span class="p">()</span> <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">origin</span> <span class="ow">is</span> <span class="n">target</span><span class="p">)</span>
        <span class="n">hbar_next</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">h</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">face</span><span class="o">.</span><span class="n">_hiter</span><span class="p">()</span> <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">origin</span> <span class="ow">is</span> <span class="n">origin</span><span class="p">)</span>

        <span class="n">hbar_prev</span> <span class="o">=</span> <span class="n">h_next</span><span class="o">.</span><span class="n">_prev</span>
        <span class="n">h_prev</span> <span class="o">=</span> <span class="n">hbar_next</span><span class="o">.</span><span class="n">_prev</span>

        <span class="c1"># Take care of the face to the left of h. This face keeps its</span>
        <span class="c1"># identifier. A new face is create to the right of it.</span>
        <span class="n">h</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="n">h_next</span>
        <span class="n">h_next</span><span class="o">.</span><span class="n">_prev</span> <span class="o">=</span> <span class="n">h</span>
        <span class="n">h</span><span class="o">.</span><span class="n">_prev</span> <span class="o">=</span> <span class="n">h_prev</span>
        <span class="n">h_prev</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="n">h</span>
        <span class="n">h</span><span class="o">.</span><span class="n">_face</span> <span class="o">=</span> <span class="n">face</span>

        <span class="n">face</span><span class="o">.</span><span class="n">_halfedge</span> <span class="o">=</span> <span class="n">h</span>
        <span class="n">face</span><span class="o">.</span><span class="n">_valence</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Take care of the face to the right of h. This is a new face that</span>
        <span class="c1"># takes over some of the existing halfedges of the original face.</span>
        <span class="n">fbar</span> <span class="o">=</span> <span class="n">Face</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">))</span>
        <span class="n">fbar</span><span class="o">.</span><span class="n">_halfedge</span> <span class="o">=</span> <span class="n">hbar</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fbar</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_attr_values</span><span class="p">(</span><span class="n">fbar</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_fattr</span><span class="p">)</span>

        <span class="n">hbar</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="n">hbar_next</span>
        <span class="n">hbar_next</span><span class="o">.</span><span class="n">_prev</span> <span class="o">=</span> <span class="n">hbar</span>
        <span class="n">hbar</span><span class="o">.</span><span class="n">_prev</span> <span class="o">=</span> <span class="n">hbar_prev</span>
        <span class="n">hbar_prev</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="n">hbar</span>

        <span class="c1"># The halfedge loop around the new face has been established. Set</span>
        <span class="c1"># the face attribute of each halfedge in this loop to fbar.</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">hbar</span><span class="o">.</span><span class="n">_face</span> <span class="o">=</span> <span class="n">fbar</span>
            <span class="n">hbar</span> <span class="o">=</span> <span class="n">hbar</span><span class="o">.</span><span class="n">_next</span>

            <span class="k">if</span> <span class="n">fbar</span><span class="o">.</span><span class="n">_halfedge</span> <span class="ow">is</span> <span class="n">hbar</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="n">h</span></div>


<div class="viewcode-block" id="Mesh.split_halfedge">
<a class="viewcode-back" href="../../api/m3sh.hds.Mesh.split_halfedge.html#m3sh.hds.Mesh.split_halfedge">[docs]</a>
    <span class="k">def</span> <span class="nf">split_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">halfedge</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">triangulate</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Split halfedge.</span>

<span class="sd">        Subdivides an edge by inserting a new vertex. The resulting</span>
<span class="sd">        polygonal faces to the left and right of the edge are</span>
<span class="sd">        triangulated on request.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        halfedge : Halfedge</span>
<span class="sd">            Halfedge to split.</span>
<span class="sd">        point : array_like, optional</span>
<span class="sd">            Coordinates of the inserted vertex. By default the halfedges&#39;</span>
<span class="sd">            :attr:`~Halfedge.midpoint` is used.</span>
<span class="sd">        triangulate : bool, optional</span>
<span class="sd">            Triangle fan like triangulation of neighboring faces.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Vertex</span>
<span class="sd">            The newly inserted vertex.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_deleted</span>

        <span class="c1"># Take the edge midpoint as vertex location if none is given.</span>
        <span class="k">if</span> <span class="n">point</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">midpoint</span>

        <span class="c1"># Get the original endpoints of the halfedge. Add the new point</span>
        <span class="c1"># as a vertex of the mesh.</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_origin</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_target</span>

        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_halfedge</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">h</span><span class="o">.</span><span class="n">_face</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_face</span>
        <span class="n">h</span><span class="o">.</span><span class="n">_pair</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span>
        <span class="n">h</span><span class="o">.</span><span class="n">_prev</span> <span class="o">=</span> <span class="n">halfedge</span>
        <span class="n">h</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_next</span>
        <span class="n">h</span><span class="o">.</span><span class="n">_next</span><span class="o">.</span><span class="n">_prev</span> <span class="o">=</span> <span class="n">h</span>

        <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">h</span><span class="o">.</span><span class="n">_face</span><span class="o">.</span><span class="n">_valence</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">v</span><span class="o">.</span><span class="n">_halfedge</span> <span class="o">=</span> <span class="n">h</span>

        <span class="n">hh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_halfedge</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">hh</span><span class="o">.</span><span class="n">_face</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_face</span>
        <span class="n">hh</span><span class="o">.</span><span class="n">_pair</span> <span class="o">=</span> <span class="n">halfedge</span>
        <span class="n">hh</span><span class="o">.</span><span class="n">_prev</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span>
        <span class="n">hh</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_next</span>
        <span class="n">hh</span><span class="o">.</span><span class="n">_next</span><span class="o">.</span><span class="n">_prev</span> <span class="o">=</span> <span class="n">hh</span>

        <span class="k">if</span> <span class="n">hh</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hh</span><span class="o">.</span><span class="n">_face</span><span class="o">.</span><span class="n">_valence</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># ... this change has to be reflected in the halfedge dictionary</span>
        <span class="c1"># by reinserting them with a new key.</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">w</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="p">[</span><span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">halfedge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="p">[</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span>

        <span class="c1"># Take care of the combinatorial attributes of halfedge and its</span>
        <span class="c1"># pair. Since one of their endpoints changed ...</span>
        <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_pair</span> <span class="o">=</span> <span class="n">h</span>
        <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_target</span> <span class="o">=</span> <span class="n">v</span>
        <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="n">hh</span>

        <span class="n">halfedge</span><span class="o">.</span><span class="n">_pair</span> <span class="o">=</span> <span class="n">hh</span>
        <span class="n">halfedge</span><span class="o">.</span><span class="n">_target</span> <span class="o">=</span> <span class="n">v</span>
        <span class="n">halfedge</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="n">h</span>

        <span class="c1"># The split has resulted in polygonal faces to left and right of</span>
        <span class="c1"># halfedge. On request, these faces are triangulated.</span>
        <span class="k">if</span> <span class="n">triangulate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fan_triangulation</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fan_triangulation</span><span class="p">(</span><span class="n">hh</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">v</span></div>


    <span class="k">def</span> <span class="nf">_add_attr_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Add attribute values.</span>

<span class="sd">        Extend data block by a value provided as keyword argument</span>
<span class="sd">        or the by the default value of the data block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : Vertex or Halfedge or Face</span>
<span class="sd">            The mesh item.</span>
<span class="sd">        *args : list</span>
<span class="sd">            List of data block descriptors.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Dictionary of attribute names and values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">default</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">_array_append</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Create and add new halfedge.</span>

<span class="sd">        Generate new halfedge and take care of its :attr:`~Halfedge.origin`,</span>
<span class="sd">        :attr:`~Halfedge.target`, and :attr:`~Halfedge.pair` attributes. The</span>
<span class="sd">        :attr:`~Halfedge.next`, :attr:`~Halfedge.prev`, and</span>
<span class="sd">        :attr:`~Halfedge.face` attributes retain their default :obj:`None`</span>
<span class="sd">        values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        v : Vertex</span>
<span class="sd">            Origin vertex of the halfedge.</span>
<span class="sd">        w : Vertex</span>
<span class="sd">            Target vertex of the halfedge</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Attribute name and value pairs.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NonManifoldError</span>
<span class="sd">            If there are topological issues adding the halfedge.</span>
<span class="sd">        TypeError</span>
<span class="sd">            If managed attributes could not be set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Halfedge</span>
<span class="sd">            Halfedge pointing from `v` to `w`.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        If the opposite halfedge is already mapped, its :attr:`~Halfedge.pair`</span>
<span class="sd">        attribute is set accordingly. This is an internal helper function for</span>
<span class="sd">        face creation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Need instances of the Vertex class, not integers. Vertices have</span>
        <span class="c1"># to belong to the mesh instance.</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">_mesh</span> <span class="ow">is</span> <span class="bp">self</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">)</span> <span class="ow">and</span> <span class="n">w</span><span class="o">.</span><span class="n">_mesh</span> <span class="ow">is</span> <span class="bp">self</span>

        <span class="c1"># This edge is topologically degenerate if the origin and target</span>
        <span class="c1"># vertex coincide. Not to be confused with geometrically degenerate</span>
        <span class="c1"># if the vertex locations coincide.</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="n">w</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;topologically degenerate edge (</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">_idx</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">w</span><span class="o">.</span><span class="n">_idx</span><span class="si">}</span><span class="s1">)&#39;</span>
            <span class="k">raise</span> <span class="n">NonManifoldError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># In case we are re-using previously deleted vertices. The set of</span>
        <span class="c1"># outgoing halfedges has to be empty.</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">_deleted</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">w</span><span class="o">.</span><span class="n">_deleted</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># If the edge (v, w) is already mapped we have a topological</span>
            <span class="c1"># problem unless it is mapped as a boundary halfedge.</span>
            <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;edge (</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">_idx</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">w</span><span class="o">.</span><span class="n">_idx</span><span class="si">}</span><span class="s1">) is non-manifold&#39;</span>
                <span class="k">raise</span> <span class="n">NonManifoldError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># The edge is not mapped yet. Create it and set its pair</span>
            <span class="c1"># pointer if the pair has been mapped.</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">Halfedge</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
            <span class="n">h</span><span class="o">.</span><span class="n">_pair</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>

            <span class="c1"># If the pair is mapped, also set its pair pointer to the</span>
            <span class="c1"># newly created halfedge.</span>
            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">_pair</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">h</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_pair</span> <span class="o">=</span> <span class="n">h</span>

            <span class="c1"># Insert h into the dictionary of all halfedges and add it</span>
            <span class="c1"># to the set of outgoing halfedges of its origin vertex.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_attr_values</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_hattr</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># Attributes that are not managed via a corresponding mesh</span>
            <span class="c1"># data block become ordinary halfedge instance attributes.</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># This calls the setter method of a property with the name</span>
                <span class="c1"># &#39;key&#39; if it exists (guard with if-condition to prevent</span>
                <span class="c1"># setting the value of managed attributes again).</span>
                <span class="c1"># if key not in (attr for _, attr, _ in self._hattr):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="n">v</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">w</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">h</span>

    <span class="k">def</span> <span class="nf">_pop_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Remove halfedge from halfedge container.</span>

<span class="sd">        Called as a helper function whenever a halfedge is deleted during</span>
<span class="sd">        topological mesh modification. By design, a valid halfedge structure</span>
<span class="sd">        **never** contains deleted halfedges in its halfedge dictionary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        h : Halfedge</span>
<span class="sd">            The halfedge to be removed.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KeyError</span>
<span class="sd">            If the halfedge could not be removed. This indicates a corrupted</span>
<span class="sd">            halfedge data structure or erroneous code, e.g. trying to remove</span>
<span class="sd">            a halfedge twice.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Combinatorial halfedge attributes are neither invalidated nor changed</span>
<span class="sd">        in any way.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">h</span><span class="o">.</span><span class="n">_deleted</span>

        <span class="c1"># In case there are external references to this halfedge we set its</span>
        <span class="c1"># deleted flag. In this way user code can check if a halfedge is</span>
        <span class="c1"># still valid without searching through the halfedge container.</span>
        <span class="n">h</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">v</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_origin</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_target</span>

        <span class="c1"># Remove the halfedge from the dictionary that holds all halfedges.</span>
        <span class="c1"># Also remove it from the set of outgoing halfedges of its origin.</span>
        <span class="c1"># Both operations can a KeyError if the halfedge is not present.</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_push_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Add halfedge to halfedge container.</span>

<span class="sd">        (Re)insert existing halfedge into the dictionary of all halfedges.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        h : Halfedge</span>
<span class="sd">            Halfedge to be re-inserted.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This method should **only** be applied to halfedges that have</span>
<span class="sd">        previously been removed by :meth:`_pop_halfedge`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">h</span><span class="o">.</span><span class="n">_deleted</span>

        <span class="c1"># Assumes that h has been removed by _pop_halfedge. Undo all the</span>
        <span class="c1"># changes that were made in said function.</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_origin</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_target</span>

        <span class="k">assert</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span>
        <span class="k">assert</span> <span class="n">h</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>

        <span class="n">h</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_origin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Set halfedge origin vertex.</span>

<span class="sd">        In-place connectivity modification.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        h : Halfedge</span>
<span class="sd">            Valid mesh halfedge.</span>
<span class="sd">        v : Vertex</span>
<span class="sd">            Origin vertex, different from ``h.target``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">h</span><span class="o">.</span><span class="n">_deleted</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_origin</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_target</span>

        <span class="k">assert</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">w</span>
        <span class="k">assert</span> <span class="n">h</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">w</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span>

        <span class="n">h</span><span class="o">.</span><span class="n">_origin</span> <span class="o">=</span> <span class="n">v</span>

    <span class="k">def</span> <span class="nf">_set_target</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Set halfedge target vertex.</span>

<span class="sd">        In-place connectivity modification.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        h : Halfedge</span>
<span class="sd">            Valid mesh halfedge.</span>
<span class="sd">        v : Vertex</span>
<span class="sd">            Target vertex, different from ``h.origin``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">h</span><span class="o">.</span><span class="n">_deleted</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_origin</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_target</span>

        <span class="k">assert</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">u</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span>

        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">w</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span>

        <span class="n">h</span><span class="o">.</span><span class="n">_target</span> <span class="o">=</span> <span class="n">v</span>

    <span class="k">def</span> <span class="nf">_set_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Set halfedge vertices.</span>

<span class="sd">        In-place connectivity modification. No halfedge attributes except</span>
<span class="sd">        :attr:`~Halfedge.origin` and :attr:`~Halfedge.target` are changed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        h : Halfedge</span>
<span class="sd">            Halfedge of a mesh, not marked as deleted.</span>
<span class="sd">        v : Vertex</span>
<span class="sd">            Halfedge origin vertex.</span>
<span class="sd">        w : Vertex</span>
<span class="sd">            Halfedge target vertex, different from `v`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">w</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_pop_halfedge</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

        <span class="n">h</span><span class="o">.</span><span class="n">_origin</span> <span class="o">=</span> <span class="n">v</span>
        <span class="n">h</span><span class="o">.</span><span class="n">_target</span> <span class="o">=</span> <span class="n">w</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_push_halfedge</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_fan_triangulation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">halfedge</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Triangulate face with triangle fan.</span>

<span class="sd">        The faces of the triangle fan can be traversed with a simple</span>
<span class="sd">        loop:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            stop =</span>
<span class="sd">            h = halfedge</span>

<span class="sd">            while h is not stop:</span>
<span class="sd">                f = h.face</span>
<span class="sd">                h = h.prev.pair</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        halfedge : Halfedge</span>
<span class="sd">            Origin of `halfedge` defines the apex of the fan.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Halfedge</span>
<span class="sd">            Fan delimiting halfedge, equal to ``halfedge.prev.pair``</span>
<span class="sd">            before triangulation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">v</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_origin</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_face</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_next</span>

        <span class="c1"># Need to copy that value before it gets changed by the</span>
        <span class="c1"># edge insertion method.</span>
        <span class="n">stop_here</span> <span class="o">=</span> <span class="n">halfedge</span><span class="o">.</span><span class="n">_prev</span><span class="o">.</span><span class="n">_prev</span>

        <span class="k">while</span> <span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">stop_here</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">insert_halfedge</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">_target</span><span class="p">)</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_next</span>

    <span class="k">def</span> <span class="nf">_clone_connectivity_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Clone mesh connnectivity.</span>

<span class="sd">        Generates shallow copies of user defined vertex and face</span>
<span class="sd">        attributes, i.e., all attributes not managed by the halfedge</span>
<span class="sd">        structure.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Mesh</span>
<span class="sd">            Template mesh connectivity.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vmap : dict</span>
<span class="sd">            Maps vertices of `other` to `self`.</span>
<span class="sd">        hmap : dict</span>
<span class="sd">            Maps halfedges of `other` to `self`.</span>
<span class="sd">        fmap : dict</span>
<span class="sd">            Maps faces of `other` to `self`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The following way of copying a mesh is not intended, use the</span>
        <span class="c1"># copy() method instead.</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;self cannot serve as template mesh connectivity&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># Replace vertex and face containers with shallow copies of</span>
        <span class="c1"># vertices and faces of the template mesh.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">copy</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_verts</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">copy</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_faces</span><span class="p">]</span>

        <span class="c1"># Clear halfedge related containers. This wipes the mesh</span>
        <span class="c1"># combinatorics completely.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="c1"># Maps that assign each item of the template mesh the</span>
        <span class="c1"># corresponding item of the cloned mesh.</span>
        <span class="n">vmap</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">w</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_verts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="p">)}</span>
        <span class="n">fmap</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="n">g</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_faces</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">)}</span>
        <span class="n">hmap</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># Clone halfedges. Need cloned vertices to generate halfedges.</span>
        <span class="c1"># Sanity check: halfedges should never be marked as deleted.</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_halfs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">h</span><span class="o">.</span><span class="n">_deleted</span>

            <span class="n">v_new</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="n">w_new</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>
            <span class="n">h_new</span> <span class="o">=</span> <span class="n">Halfedge</span><span class="p">(</span><span class="n">v_new</span><span class="p">,</span> <span class="n">w_new</span><span class="p">)</span>
            <span class="n">hmap</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">h_new</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="p">[</span><span class="n">v_new</span><span class="p">,</span> <span class="n">w_new</span><span class="p">]</span> <span class="o">=</span> <span class="n">h_new</span>

        <span class="c1"># Set halfedge attribute of cloned vertices. Since this loops</span>
        <span class="c1"># over all cloned vertices we can also set their mesh attribute.</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_verts</span><span class="p">:</span>
            <span class="n">v_new</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="n">v_new</span><span class="o">.</span><span class="n">_mesh</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">v_new</span><span class="o">.</span><span class="n">_halfedge</span> <span class="o">=</span> <span class="p">(</span><span class="n">hmap</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">_halfedge</span><span class="p">]</span>
                               <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">_halfedge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">v_new</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">v_new</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">hmap</span><span class="p">[</span><span class="n">h</span><span class="p">])</span>

        <span class="c1"># Copy the faces. Only one pass needed, requires valid halfedge</span>
        <span class="c1"># map.</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_faces</span><span class="p">:</span>
            <span class="n">f_new</span> <span class="o">=</span> <span class="n">fmap</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
            <span class="n">f_new</span><span class="o">.</span><span class="n">_halfedge</span> <span class="o">=</span> <span class="p">(</span><span class="n">hmap</span><span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">_halfedge</span><span class="p">]</span>
                               <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">_halfedge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Set remaining attributes of cloned halfedges with the help of</span>
        <span class="c1"># the face and halfedge maps.</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_halfs</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">h_new</span> <span class="o">=</span> <span class="n">hmap</span><span class="p">[</span><span class="n">h</span><span class="p">]</span>
            <span class="n">h_new</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="n">hmap</span><span class="p">[</span><span class="n">h</span><span class="o">.</span><span class="n">_next</span><span class="p">]</span>
            <span class="n">h_new</span><span class="o">.</span><span class="n">_prev</span> <span class="o">=</span> <span class="n">hmap</span><span class="p">[</span><span class="n">h</span><span class="o">.</span><span class="n">_prev</span><span class="p">]</span>
            <span class="n">h_new</span><span class="o">.</span><span class="n">_pair</span> <span class="o">=</span> <span class="n">hmap</span><span class="p">[</span><span class="n">h</span><span class="o">.</span><span class="n">_pair</span><span class="p">]</span>
            <span class="n">h_new</span><span class="o">.</span><span class="n">_face</span> <span class="o">=</span> <span class="n">fmap</span><span class="p">[</span><span class="n">h</span><span class="o">.</span><span class="n">_face</span><span class="p">]</span> <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">vmap</span><span class="p">,</span> <span class="n">hmap</span><span class="p">,</span> <span class="n">fmap</span>

    <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">contains_test</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Perform sanity checks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">halfs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">halfs</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">v</span><span class="o">.</span><span class="n">_deleted</span> <span class="ow">or</span> <span class="n">v</span><span class="o">.</span><span class="n">_halfedge</span> <span class="ow">is</span> <span class="kc">None</span>

            <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">halfs</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                <span class="k">assert</span> <span class="n">h</span><span class="o">.</span><span class="n">_origin</span> <span class="ow">is</span> <span class="n">v</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">assert</span> <span class="n">h</span><span class="o">.</span><span class="n">_origin</span> <span class="ow">is</span> <span class="n">v</span>
            <span class="k">assert</span> <span class="n">h</span><span class="o">.</span><span class="n">_target</span> <span class="ow">is</span> <span class="n">w</span>
            <span class="k">assert</span> <span class="n">h</span><span class="o">.</span><span class="n">_pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="k">assert</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>

            <span class="n">h</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">contains_test</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">_idx</span><span class="p">]</span> <span class="ow">is</span> <span class="n">v</span>

            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">_deleted</span><span class="p">:</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">_halfedge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">v</span><span class="o">.</span><span class="n">_halfedge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                    <span class="k">assert</span> <span class="n">v</span><span class="o">.</span><span class="n">_halfedge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

            <span class="n">v</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">contains_test</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">_idx</span><span class="p">]</span> <span class="ow">is</span> <span class="n">f</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">_deleted</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">f</span><span class="o">.</span><span class="n">_halfedge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

            <span class="n">f</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">contains_test</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">private_name</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vattr</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">private_name</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">private_name</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hattr</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">private_name</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">private_name</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fattr</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">private_name</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_viter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generator expression skipping deleted vertices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">_deleted</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_viter_frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generator expression skipping deleted vertices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_viter</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">_fiter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generator expression skipping deleted faces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">_deleted</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_fiter_frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generator expression skipping deleted faces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fiter</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">_hiter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generator expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_hiter_frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generator expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">_eiter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generator expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">h</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfs</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">_origin</span><span class="o">.</span><span class="n">_idx</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">.</span><span class="n">_target</span><span class="o">.</span><span class="n">_idx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eiter_frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generator expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_eiter</span><span class="p">()))</span></div>



<div class="viewcode-block" id="Vertex">
<a class="viewcode-back" href="../../api/m3sh.hds.Vertex.html#m3sh.hds.Vertex">[docs]</a>
<span class="k">class</span> <span class="nc">Vertex</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Vertex base class.</span>

<span class="sd">    Vertices are considered as abstract topological entities. Vertex</span>
<span class="sd">    coordinates are assigned when a vertex becomes part of a mesh. Its</span>
<span class="sd">    coordinates can then be accessed via the :attr:`point` property .</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    index : int</span>
<span class="sd">        Vertex index.</span>
<span class="sd">    parent : Mesh, optional</span>
<span class="sd">        The parent mesh object.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    In addition to :attr:`index`, implementations of the special functions</span>
<span class="sd">    :meth:`~object.__int__` and :meth:`~object.__index__` are provided.</span>
<span class="sd">    The latter makes it possible to use vertex instances as list indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Initialize combinatorial/topological attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span> <span class="o">=</span> <span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Initialize internal state attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">VertexFlag</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Vertex(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="si">}</span><span class="s1">)&#39;</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">point</span> <span class="o">=</span> <span class="s1">&#39;[None]&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;v </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">point</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_flags</span><span class="si">}</span><span class="s1">&#39;</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;v </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">point</span><span class="si">}</span><span class="s1">&#39;</span>

<div class="viewcode-block" id="Vertex.__index__">
<a class="viewcode-back" href="../../api/m3sh.hds.Vertex.__index__.html#m3sh.hds.Vertex.__index__">[docs]</a>
    <span class="k">def</span> <span class="fm">__index__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Vertex index.</span>

<span class="sd">        Vertices can be used directly as list and array indices, i.e.,</span>
<span class="sd">        one can write ``some_list[v]`` instead of the slightly longer</span>
<span class="sd">        ``some_list[v.index]`` expression.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Vertex index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span></div>


<div class="viewcode-block" id="Vertex.__int__">
<a class="viewcode-back" href="../../api/m3sh.hds.Vertex.__int__.html#m3sh.hds.Vertex.__int__">[docs]</a>
    <span class="k">def</span> <span class="fm">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Vertex index.</span>

<span class="sd">        The expression ``int(v)`` is equivalent to ``v.index``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Vertex index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span></div>


    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Experimental NumPy support.</span>

<span class="sd">        There has been a change in the signature of __array__ from</span>
<span class="sd">        NumPy version 1.26 to 2.0 (the signature used here).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : data-type, optional</span>
<span class="sd">            The desired data type for the array.</span>
<span class="sd">        copy : bool, optional</span>
<span class="sd">            If :obj:`True` then the array data is copied. If :obj:`None`,</span>
<span class="sd">            a copy will only be made if necessary. For :obj:`False` it</span>
<span class="sd">            raises a :class:`ValueError` if a copy cannot be avoided.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `copy` evaluates to :obj:`False` and a copy cannot be</span>
<span class="sd">            avoided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ~numpy.ndarray</span>
<span class="sd">            Array of vertex coordinates.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        If no copy is requested (or implied by data type conversion) the</span>
<span class="sd">        returned value is a view of the mesh&#39;s vertex coordinate array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Vertex index.</span>

<span class="sd">        Position of the vertex in the list :attr:`~Mesh.vertices` of all</span>
<span class="sd">        mesh vertices. Same as ``int(self)``.</span>

<span class="sd">        :type: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">point</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Vertex coordinates.</span>

<span class="sd">        Read and write access to vertex coordinates. View of the</span>
<span class="sd">        vertex coordinate array. Requires a valid parent mesh.</span>

<span class="sd">        :type: ~numpy.ndarray</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This attribute can be set from any :term:`array_like` vertex</span>
<span class="sd">        coordinate representation. Coordinates are assigned to the</span>
<span class="sd">        corresponding row of the parent mesh&#39;s coordinate array. In</span>
<span class="sd">        particular, NumPy&#39;s :term:`broadcast` rules apply.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>

    <span class="nd">@point</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Vertex flags.</span>

<span class="sd">        Read and write access to vertex flags.</span>

<span class="sd">        :type: VertexFlag</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span>

    <span class="nd">@flags</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">flags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">halfedge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Outward pointing halfedge.</span>

<span class="sd">        A halfedge that starts at the vertex or :obj:`None` for isolated</span>
<span class="sd">        vertices.</span>

<span class="sd">        :type: Halfedge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Vertex degree.</span>

<span class="sd">        The number of adjacent vertices, equivalent to the number of</span>
<span class="sd">        incident edges -- also called the valence of a vertex.</span>

<span class="sd">        :type: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_manifold</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="bp">self</span><span class="p">])</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_degree</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="bp">self</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">deleted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Internal state.</span>

<span class="sd">        Topological mesh modification (e.g., edge conctractions) render</span>
<span class="sd">        vertices as deleted when they do no longer contribute to a mesh&#39;s</span>
<span class="sd">        combinatorics.</span>

<span class="sd">        :type: bool</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Calling :meth:`~Mesh.clean` removes all deleted vertices from the</span>
<span class="sd">        vertex container of a mesh.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Topological state.</span>

<span class="sd">        A vertex is defined to be a boundary vertex if it is incident to</span>
<span class="sd">        a boundary halfedge.</span>

<span class="sd">        :type: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">boundary</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hiter</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isolated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Topological state.</span>

<span class="sd">        A vertex is isolated if its :attr:`~Vertex.halfedge` attribute</span>
<span class="sd">        holds a :obj:`None` value. Topologically, isolated vertices are</span>
<span class="sd">        not linked to any other mesh items and form their own connected</span>
<span class="sd">        component.</span>

<span class="sd">        :type: bool</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Isolated vertices are treated as **manifold** vertices. Their</span>
<span class="sd">        presence does not influence the halfedge data structure</span>
<span class="sd">        functionality negatively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>

        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span>
        <span class="n">vhout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>

        <span class="c1"># If h is set it has to be a member of vhout. In particular this</span>
        <span class="c1"># imples that vhout is not empty if h is set.</span>
        <span class="k">assert</span> <span class="n">h</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">vhout</span>

        <span class="c1"># If h is not set the set vhout has to be empty.</span>
        <span class="k">assert</span> <span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">vhout</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span> <span class="ow">is</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_manifold</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Topological state.</span>

<span class="sd">        Isolated vertices are considered manifold vertices as they</span>
<span class="sd">        don&#39;t break the halfedge structure.</span>

<span class="sd">        :type: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>

        <span class="c1"># We cannot rely on self.halfedge since this allows us only to</span>
        <span class="c1"># visit one fan of triangles attached to the vertex. The point</span>
        <span class="c1"># is to find out if there is more than one such triangle fan.</span>
        <span class="n">halfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">_vhout</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">halfs</span><span class="p">:</span>                       <span class="c1"># isolated vertex is fine</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># There should be either one closed triangle fan or one open</span>
        <span class="c1"># triangle fan attached. There can never be more than two None</span>
        <span class="c1"># faces in such a triangle fan (in case of a boundary vertex).</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="p">[</span><span class="n">h</span><span class="o">.</span><span class="n">face</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">halfs</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">h</span><span class="o">.</span><span class="n">pair</span><span class="o">.</span><span class="n">face</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">halfs</span><span class="p">]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">faces</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Interior vertex: faces has to form a single closed fan of</span>
            <span class="c1"># triangles. Boundary vertex: single open fan of triangles.</span>
            <span class="n">fmap</span> <span class="o">=</span> <span class="p">{</span><span class="n">h</span><span class="o">.</span><span class="n">face</span><span class="p">:</span> <span class="n">h</span><span class="o">.</span><span class="n">pair</span><span class="o">.</span><span class="n">face</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">halfs</span><span class="p">}</span>
            <span class="n">loop</span> <span class="o">=</span> <span class="p">[</span><span class="n">faces</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>

            <span class="k">while</span> <span class="n">fmap</span><span class="p">:</span>
                <span class="c1"># Want to see the KeyError, this should never happen</span>
                <span class="c1"># and indicates unexpected behavior.</span>
                <span class="n">loop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fmap</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">loop</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

                <span class="k">if</span> <span class="n">loop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">loop</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">break</span>

            <span class="c1"># Everything is fine if we reach this point and the loop has</span>
            <span class="c1"># closed while fmap was exhausted.</span>
            <span class="k">if</span> <span class="n">loop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">loop</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">fmap</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_compute_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Vertex degree.</span>

<span class="sd">        Compute vertex degree in the canonical way. Only applicable</span>
<span class="sd">        to manifold vertices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Vertex degree.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This is an internal function only used for debugging. To access</span>
<span class="sd">        the vertex degree always use :attr:`degree`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Dangling vertices, i.e., endpoints of dangling edges are the</span>
        <span class="c1"># only vertices with degree 1. A vertex should only be in this</span>
        <span class="c1"># transitional state during mesh construction (or modification).</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_viter</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">contains_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Perform sanity checks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        contains_test : bool</span>
<span class="sd">            Enable time consuming ``__contains__()`` tests.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span><span class="o">.</span><span class="n">_deleted</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span><span class="o">.</span><span class="n">_origin</span> <span class="ow">is</span> <span class="bp">self</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_degree</span><span class="p">()</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span><span class="o">.</span><span class="n">_face</span><span class="o">.</span><span class="n">_deleted</span>

                    <span class="k">if</span> <span class="n">contains_test</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="bp">self</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span><span class="o">.</span><span class="n">_face</span>

    <span class="k">def</span> <span class="nf">_invalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Reset all combinatorial attributes.</span>

<span class="sd">        Invalidate should be called as a last step in garbage collection</span>
<span class="sd">        when removed from the corresponding container object. This should</span>
<span class="sd">        make it easier to find bugs originating from using references to</span>
<span class="sd">        deleted objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_viter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Adjacent vertex iterator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span>

        <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">h</span><span class="o">.</span><span class="n">_target</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_prev</span><span class="o">.</span><span class="n">_pair</span>

            <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span><span class="p">:</span>
                <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_fiter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Incident face iterator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span>

        <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">h</span><span class="o">.</span><span class="n">_face</span>

            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_prev</span><span class="o">.</span><span class="n">_pair</span>

            <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span><span class="p">:</span>
                <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_hiter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Incident halfedge iterator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span>

        <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">h</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_prev</span><span class="o">.</span><span class="n">_pair</span>

            <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span><span class="p">:</span>
                <span class="k">return</span></div>



<div class="viewcode-block" id="Halfedge">
<a class="viewcode-back" href="../../api/m3sh.hds.Halfedge.html#m3sh.hds.Halfedge">[docs]</a>
<span class="k">class</span> <span class="nc">Halfedge</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Halfedge base class.</span>

<span class="sd">    Halfedges store references to their vertices, the successor, predecessor,</span>
<span class="sd">    and twin halfedge as well as the incident face -- the face to its left.</span>
<span class="sd">    A closed loop of halfedges defines a face and its orientation. Successor</span>
<span class="sd">    and predecessor refer to the next and previous halfedge in such a loop.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    origin : Vertex</span>
<span class="sd">        Origin vertex of the halfedge.</span>
<span class="sd">    target : Vertex</span>
<span class="sd">        Target vertex of the halfedge.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    As halfedges are stored in a dictionary and not in a list, they do not</span>
<span class="sd">    have a canonical index value but a key that is formed by the pair of</span>
<span class="sd">    origin and target vertex.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span> <span class="o">=</span> <span class="n">origin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target</span> <span class="o">=</span> <span class="n">target</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prev</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pair</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_face</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">HalfedgeFlag</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Halfedge(</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin</span><span class="p">)</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_target</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;h (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin</span><span class="o">.</span><span class="n">_idx</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_target</span><span class="o">.</span><span class="n">_idx</span><span class="si">}</span><span class="s1">)&#39;</span> <span class="o">+</span>
                    <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_flags</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;h (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin</span><span class="o">.</span><span class="n">_idx</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_target</span><span class="o">.</span><span class="n">_idx</span><span class="si">}</span><span class="s1">)&#39;</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># def __array__(self, dtype=None, copy=None):</span>
    <span class="c1">#     &quot;&quot;&quot; Experimental NumPy support.</span>

    <span class="c1">#     There has been a change in the signature of __array__ from</span>
    <span class="c1">#     NumPy version 1.26 to 2.0 (the signature used here).</span>

    <span class="c1">#     Parameters</span>
    <span class="c1">#     ----------</span>
    <span class="c1">#     dtype : data-type, optional</span>
    <span class="c1">#         The desired data type for the array.</span>
    <span class="c1">#     copy : bool, optional</span>
    <span class="c1">#         If :obj:`True` then the array data is copied. If :obj:`None`,</span>
    <span class="c1">#         a copy will only be made if necessary. For :obj:`False` it</span>
    <span class="c1">#         raises a :class:`ValueError` if a copy cannot be avoided.</span>

    <span class="c1">#     Raises</span>
    <span class="c1">#     ------</span>
    <span class="c1">#     ValueError</span>
    <span class="c1">#         If `copy` evaluates to :obj:`False` and a copy cannot be</span>
    <span class="c1">#         avoided.</span>

    <span class="c1">#     Returns</span>
    <span class="c1">#     -------</span>
    <span class="c1">#     ~numpy.ndarray</span>
    <span class="c1">#         Coordinates of halfedge direction vector.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     return self.vector</span>

<div class="viewcode-block" id="Halfedge.__contains__">
<a class="viewcode-back" href="../../api/m3sh.hds.Halfedge.__contains__.html#m3sh.hds.Halfedge.__contains__">[docs]</a>
    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Incidence test.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vertex : Vertex</span>
<span class="sd">            Vertex to be tested.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            :obj:`True` if `vertex` is one of the halfedge&#39;s vertices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The functionality would still be there even if this method was</span>
        <span class="c1"># removed because __iter__ is defined.</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">vertex</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">vertex</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target</span><span class="p">)</span></div>


<div class="viewcode-block" id="Halfedge.__iter__">
<a class="viewcode-back" href="../../api/m3sh.hds.Halfedge.__iter__.html#m3sh.hds.Halfedge.__iter__">[docs]</a>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Vertex iterator.</span>

<span class="sd">        Produces the origin and target vertex of a halfedge.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        Vertex</span>
<span class="sd">            Next vertex.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span></div>


<div class="viewcode-block" id="Halfedge.__getitem__">
<a class="viewcode-back" href="../../api/m3sh.hds.Halfedge.__getitem__.html#m3sh.hds.Halfedge.__getitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Vertex access.</span>

<span class="sd">        Vertex access by relative index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int</span>
<span class="sd">            Relative vertex index, either 0 or 1.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        IndexError</span>
<span class="sd">            If `index` is out of bounds.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Vertex</span>
<span class="sd">            Origin or target vertex of a halfedge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>

        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target</span>

        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1"> out of range(0, 2)&#39;</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Halfedge origin vertex.</span>

<span class="sd">        :type: Vertex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">target</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Halfedge target vertex.</span>

<span class="sd">        :type: Vertex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Halfedge direction vector.</span>

<span class="sd">        The vector ``self.target.point - self.origin.point``.</span>

<span class="sd">        :type: ~numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target</span><span class="o">.</span><span class="n">point</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span><span class="o">.</span><span class="n">point</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">midpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Halfedge midpoint.</span>

<span class="sd">        The point ``0.5 * (self.origin.point + self.target.point)``.</span>

<span class="sd">        :type: ~numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin</span><span class="o">.</span><span class="n">point</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target</span><span class="o">.</span><span class="n">point</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Successor halfedge.</span>

<span class="sd">        Next halfedge in a face defining halfedge loop.</span>

<span class="sd">        :type: Halfedge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">prev</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Predecessor halfedge.</span>

<span class="sd">        Previous halfedge in a face defining halfedge loop.</span>

<span class="sd">        :type: Halfedge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prev</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pair</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Opposite halfedge.</span>

<span class="sd">        Halfedge pointing in the opposite direction.</span>

<span class="sd">        :type: Halfedge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pair</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">face</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Incident face.</span>

<span class="sd">        The face to left of the halfedge or :py:obj:`None` in case of</span>
<span class="sd">        a boundary halfedge.</span>

<span class="sd">        :type: Face</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_face</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Halfedge flags.</span>

<span class="sd">        Read and write access to halfedge flags.</span>

<span class="sd">        :type: HalfedgeFlag</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span>

    <span class="nd">@flags</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">flags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">deleted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Internal state.</span>

<span class="sd">        Topological mesh modification (e.g., edge conctractions) may</span>
<span class="sd">        render halfedges as deleted when they do no longer contribute</span>
<span class="sd">        to a mesh&#39;s combinatorics.</span>

<span class="sd">        :type: bool</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The halfedge dictionary :attr:`~Mesh.halfedges` of a mesh will</span>
<span class="sd">        never contain deleted halfedges.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Topological state.</span>

<span class="sd">        A halfedge is called a boundary halfedge if its :attr:`face`</span>
<span class="sd">        attribute evaluates to :obj:`None`.</span>

<span class="sd">        :type: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">collapsible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Topological state.</span>

<span class="sd">        A edge joining non-boundary vertices of a **triangle mesh** is</span>
<span class="sd">        collapsible if the neighborhoods of :attr:`origin` and :attr:`target`</span>
<span class="sd">        vertex intersect in the two vertices opposite the query edge. The</span>
<span class="sd">        test tries to handle meshes with higher valence faces but may not</span>
<span class="sd">        always give a correct answer.</span>

<span class="sd">        :type: bool</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        For technical reasons, **boundary halfedges** are always classified</span>
<span class="sd">        as non-collapsible.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">one_sided_check</span><span class="p">(</span><span class="n">h</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">h</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">assert</span> <span class="n">h</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_compute_loop_len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1"># The adjacent boundary loop has only three faces.</span>
                <span class="c1"># Collapsing the halfedge would change the topology.</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">_face</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v_neigh</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">w_neigh</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="n">h</span><span class="o">.</span><span class="n">_next</span><span class="o">.</span><span class="n">_target</span><span class="p">}:</span>
                    <span class="k">return</span> <span class="kc">True</span>

                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># Test makes no sense for deleted halfedges, they are not part</span>
        <span class="c1"># of valid mesh combinatorics.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span>
        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target</span>

        <span class="c1"># This should never be a problem for pure triangle meshes but</span>
        <span class="c1"># can happen for general polygonal meshes.</span>
        <span class="n">v_faces</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">_fiter</span><span class="p">()}</span> <span class="o">-</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_face</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_face</span><span class="p">}</span>
        <span class="n">w_faces</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">w</span><span class="o">.</span><span class="n">_fiter</span><span class="p">()}</span> <span class="o">-</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_face</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_face</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">v_faces</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">w_faces</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Collect neighbors in a set to compute one-ring intersection.</span>
        <span class="n">v_neigh</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">_viter</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">w</span><span class="p">}</span>
        <span class="n">w_neigh</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">w</span><span class="o">.</span><span class="n">_viter</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">v</span><span class="p">}</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">one_sided_check</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pair</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">one_sided_check</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Interior edge that connects boundaries is not collapsible.</span>
        <span class="c1"># Result would be a non-manifold mesh.</span>
        <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">boundary</span> <span class="ow">and</span> <span class="n">w</span><span class="o">.</span><span class="n">boundary</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_face</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next</span><span class="o">.</span><span class="n">_target</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_face</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_next</span><span class="o">.</span><span class="n">_target</span>

                <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="n">q</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>

                <span class="k">if</span> <span class="n">v_neigh</span> <span class="o">==</span> <span class="n">w_neigh</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>

                <span class="c1"># Triangular faces to the left and right. One rings of</span>
                <span class="c1"># endpoints have to intersect in the vertices opposite</span>
                <span class="c1"># the query edge.</span>
                <span class="k">if</span> <span class="n">v_neigh</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">w_neigh</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">}:</span>
                    <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Triangular face to the left and n-gon to the right.</span>
                <span class="k">if</span> <span class="n">v_neigh</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">w_neigh</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="n">p</span><span class="p">}:</span>
                    <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Triangular face to the right and n-gon to the left.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_face</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_next</span><span class="o">.</span><span class="n">_target</span>

                <span class="k">if</span> <span class="n">v_neigh</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">w_neigh</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="n">q</span><span class="p">}:</span>
                    <span class="k">return</span> <span class="kc">True</span>

            <span class="c1"># There are n-gons to the left and to the right of the</span>
            <span class="c1"># query edge.</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flippable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Topological state.</span>

<span class="sd">        A non-boundary edge of a triangle mesh can be flipped if the</span>
<span class="sd">        vertices opposite the edge are not adjacent.</span>

<span class="sd">        :type: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># An interior edge can only be flipped if the incident faces are</span>
        <span class="c1"># triangles.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_face</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_face</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># The vertices opposite the query edge may not belong to the same</span>
        <span class="c1"># face. Happens if one of the edge&#39;s endpoints is of degree three.</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next</span><span class="o">.</span><span class="n">_target</span>
        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_next</span><span class="o">.</span><span class="n">_target</span>

        <span class="c1"># if (v, w) in self._origin._mesh._halfs:</span>
        <span class="c1">#     return False</span>

        <span class="c1"># return True</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">w</span> <span class="ow">in</span> <span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">_fiter</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_compute_loop_len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Length of halfedge loop.</span>

<span class="sd">        Length of the closed halfedge loop starting at ``self``. For a</span>
<span class="sd">        boundary halfedge this is the length of the corresponding boundary</span>
<span class="sd">        curve.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Length of halfedge loop.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>

        <span class="n">loop_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">loop_len</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_next</span>

            <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">loop_len</span>

    <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">contains_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Perform sanity checks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        contains_test : bool</span>
<span class="sd">            Enable time consuming ``__contains__()`` tests.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target</span><span class="o">.</span><span class="n">_deleted</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_pair</span> <span class="ow">is</span> <span class="bp">self</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_origin</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_target</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next</span><span class="o">.</span><span class="n">_prev</span> <span class="ow">is</span> <span class="bp">self</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next</span><span class="o">.</span><span class="n">_origin</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_target</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prev</span><span class="o">.</span><span class="n">_next</span> <span class="ow">is</span> <span class="bp">self</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prev</span><span class="o">.</span><span class="n">_target</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prev</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_origin</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_face</span><span class="o">.</span><span class="n">_deleted</span>

            <span class="k">if</span> <span class="n">contains_test</span><span class="p">:</span>
                <span class="k">assert</span> <span class="bp">self</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_face</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_face</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_face</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_invalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Reset all combinatorial attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_pair</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prev</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_face</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_fiter_lnk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Vertex-adjacent face iterator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">h</span><span class="o">.</span><span class="n">_face</span>

            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_prev</span><span class="o">.</span><span class="n">_pair</span>

            <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_prev</span><span class="o">.</span><span class="n">_pair</span>

        <span class="k">while</span> <span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">h</span><span class="o">.</span><span class="n">_face</span>

            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_prev</span><span class="o">.</span><span class="n">_pair</span></div>



<div class="viewcode-block" id="Face">
<a class="viewcode-back" href="../../api/m3sh.hds.Face.html#m3sh.hds.Face">[docs]</a>
<span class="k">class</span> <span class="nc">Face</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Face base class.</span>

<span class="sd">    In a halfedge based mesh representation a face is defined by the</span>
<span class="sd">    closed loop of halfedges starting at the :attr:`halfedge` attribute.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    index : int</span>
<span class="sd">        Face index.</span>


<span class="sd">    The vertices of a face can be visited in several ways. Using</span>
<span class="sd">    :meth:`~m3sh.hds.Face.__len__` and :meth:`~m3sh.hds.Face.__getitem__`</span>

<span class="sd">    .. code-block:: python</span>
<span class="sd">       :linenos:</span>

<span class="sd">        for i in range(len(f)):</span>
<span class="sd">            print(f[i])</span>

<span class="sd">    is equivalent to using :meth:`~m3sh.hds.Face.__iter__`</span>

<span class="sd">    .. code-block:: python</span>
<span class="sd">       :linenos:</span>

<span class="sd">        for v in f:</span>
<span class="sd">            print(v)</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    The latter is much more efficient and preferred.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="c1"># Initialize combinatorial/topological attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span> <span class="o">=</span> <span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Initialize lazy attributes/properties.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valence</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Initialize internal state attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">FaceFlag</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Face(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="si">}</span><span class="s1">)&#39;</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">face</span> <span class="o">=</span> <span class="s1">&#39;[None]&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span> <span class="k">else</span> <span class="nb">str</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;f </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">face</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_flags</span><span class="si">}</span><span class="s1">&#39;</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;f </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">face</span><span class="si">}</span><span class="s1">&#39;</span>

<div class="viewcode-block" id="Face.__index__">
<a class="viewcode-back" href="../../api/m3sh.hds.Face.__index__.html#m3sh.hds.Face.__index__">[docs]</a>
    <span class="k">def</span> <span class="fm">__index__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Face index.</span>

<span class="sd">        Faces can be used directly as list and array indices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Face index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span></div>


<div class="viewcode-block" id="Face.__int__">
<a class="viewcode-back" href="../../api/m3sh.hds.Face.__int__.html#m3sh.hds.Face.__int__">[docs]</a>
    <span class="k">def</span> <span class="fm">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Face index.</span>

<span class="sd">        The expression ``int(f)`` is equivalent to ``f.index``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Face index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span></div>


<div class="viewcode-block" id="Face.__len__">
<a class="viewcode-back" href="../../api/m3sh.hds.Face.__len__.html#m3sh.hds.Face.__len__">[docs]</a>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Face valence.</span>

<span class="sd">        The number of incident vertices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Number of vertices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valence</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_valence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_valence</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valence</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_valence</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valence</span></div>


    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Experimental NumPy support.</span>

<span class="sd">        There has been a change in the signature of __array__ from</span>
<span class="sd">        NumPy version 1.26 to 2.0 (the signature used here).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : data-type, optional</span>
<span class="sd">            The desired data type for the array.</span>
<span class="sd">        copy : bool, optional</span>
<span class="sd">            If :obj:`True` then the array data is copied. If :obj:`None`,</span>
<span class="sd">            a copy will only be made if necessary. For :obj:`False` it</span>
<span class="sd">            raises a :class:`ValueError` if a copy cannot be avoided.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `copy` evaluates to :obj:`False` and a copy cannot be</span>
<span class="sd">            avoided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ~numpy.ndarray</span>
<span class="sd">            Array of vertex coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">point</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

<div class="viewcode-block" id="Face.__contains__">
<a class="viewcode-back" href="../../api/m3sh.hds.Face.__contains__.html#m3sh.hds.Face.__contains__">[docs]</a>
    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Vertex and halfedge containment test.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        item : Vertex or Halfedge</span>
<span class="sd">            Item to be tested for incidence with the face.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            :obj:`True` if the given item belongs to the face.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_viter</span><span class="p">())</span> <span class="ow">or</span> <span class="p">(</span><span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hiter</span><span class="p">())</span></div>


<div class="viewcode-block" id="Face.__iter__">
<a class="viewcode-back" href="../../api/m3sh.hds.Face.__iter__.html#m3sh.hds.Face.__iter__">[docs]</a>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Vertex iterator.</span>

<span class="sd">        The returned :term:`iterator` visits the vertices of ``self``</span>
<span class="sd">        starting with the ``self.halfedge.origin`` vertex.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        Vertex</span>
<span class="sd">            Next vertex in counter-clockwise traversal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">h</span><span class="o">.</span><span class="n">_origin</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_next</span>

            <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span><span class="p">:</span>
                <span class="k">return</span></div>


<div class="viewcode-block" id="Face.__getitem__">
<a class="viewcode-back" href="../../api/m3sh.hds.Face.__getitem__.html#m3sh.hds.Face.__getitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Vertex access.</span>

<span class="sd">        Vertex access by relative index, enumeration starts at</span>
<span class="sd">        ``self.halfedge.origin``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int or slice</span>
<span class="sd">            Integer or slice object.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        IndexError</span>
<span class="sd">            If `index` is outside the valid range.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Vertex</span>
<span class="sd">            The vertex at position `index`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))[</span><span class="n">index</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">vert</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vert</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">indices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">index</span><span class="o">.</span><span class="n">step</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">vert</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vert</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">return</span> <span class="p">[</span><span class="n">vert</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vert</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Face index.</span>

<span class="sd">        Position of the face in the list :attr:`~Mesh.faces` of all</span>
<span class="sd">        faces, same as ``int(self)``.</span>

<span class="sd">        :type: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Face flags.</span>

<span class="sd">        Read and write access to face flags.</span>

<span class="sd">        :type: FaceFlag</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span>

    <span class="nd">@flags</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">flags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">halfedge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Incident halfedge.</span>

<span class="sd">        One of the incident halfedges.</span>

<span class="sd">        :type: Halfedge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">valence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Face valence.</span>

<span class="sd">        Number of incident vertices. Same as ``len(self)``.</span>

<span class="sd">        :type: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">deleted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Internal state.</span>

<span class="sd">        Topological mesh modification (e.g., edge conctractions) render</span>
<span class="sd">        faces as deleted when they do no longer contribute to a mesh&#39;s</span>
<span class="sd">        combinatorics.</span>

<span class="sd">        :type: bool</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Calling :meth:`~Mesh.clean` removes all deleted faces from the</span>
<span class="sd">        face container of a mesh.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Topological state.</span>

<span class="sd">        A face is defined to be a boundary face if one of the incident</span>
<span class="sd">        edges is a boundary edge (an edge is a boundary edge if one of</span>
<span class="sd">        its two halfedges has this property).</span>

<span class="sd">        :type: bool</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        A face only incident with boundary vertices is **not** classified</span>
<span class="sd">        as a boundary face.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">pair</span><span class="o">.</span><span class="n">boundary</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hiter</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">barycenter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Face barycenter.</span>

<span class="sd">        Arithmetic mean of vertex coordinates.</span>

<span class="sd">        :type: ~numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">point</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compute_valence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hiter</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">contains_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Perform sanity checks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        contains_test : bool</span>
<span class="sd">            Enable time consuming ``__contains__()`` tests.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span><span class="o">.</span><span class="n">_deleted</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="bp">self</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_valence</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">contains_test</span><span class="p">:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span> <span class="ow">in</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_invalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Reset all combinatorial attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valence</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_viter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Incident vertex iterator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">h</span><span class="o">.</span><span class="n">_origin</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_next</span>

            <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span><span class="p">:</span>
                <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_hiter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Incident halfedge iterator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">h</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_next</span>

            <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span><span class="p">:</span>
                <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_eiter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generator expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">h</span> <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">_origin</span><span class="o">.</span><span class="n">_idx</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">.</span><span class="n">_target</span><span class="o">.</span><span class="n">_idx</span> <span class="k">else</span> <span class="n">h</span><span class="o">.</span><span class="n">pair</span>
                <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hiter</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_fiter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Edge-adjacent face iterator.</span>

<span class="sd">        This iterator defines two faces to be adjacent if they share</span>
<span class="sd">        a common edge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">h</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_face</span>

            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_next</span>

            <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span><span class="p">:</span>
                <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_fiter_lnk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Vertex-adjacent face iterator.</span>

<span class="sd">        This iterator defines two faces to be adjacent if they share</span>
<span class="sd">        a common vertex.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span><span class="o">.</span><span class="n">_pair</span>

        <span class="c1"># Find an edge that points towards a vertex of the face that is</span>
        <span class="c1"># not an edge of the face.</span>
        <span class="k">while</span> <span class="n">h</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_prev</span>

        <span class="c1"># Iterate over the incoming halfedges of vertices and yield the</span>
        <span class="c1"># adjacent face of such edges.</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">h</span><span class="o">.</span><span class="n">_face</span>

            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_prev</span>

            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">_pair</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="c1"># We have reached a halfedge of the center face. Continue</span>
            <span class="c1"># with the incoming edges of the other vertex of the edge.</span>
            <span class="k">while</span> <span class="n">h</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">_face</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_prev</span>

                <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">_pair</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_halfedge</span><span class="p">:</span>
                    <span class="k">return</span></div>



<div class="viewcode-block" id="NonManifoldError">
<a class="viewcode-back" href="../../api/m3sh.hds.NonManifoldError.html#m3sh.hds.NonManifoldError">[docs]</a>
<span class="k">class</span> <span class="nc">NonManifoldError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Manifold exception base class.</span>

<span class="sd">    Raised if an operation results in a topological configuration that</span>
<span class="sd">    violates the manifold condition.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, m3shware.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>